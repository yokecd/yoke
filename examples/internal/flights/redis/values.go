// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package redis

type Values struct {
	// Redis&reg; architecture. Allowed values: `standalone` or `replication`
	Architecture string `json:"architecture,omitempty" yaml:"architecture,omitempty" mapstructure:"architecture,omitempty"`

	// Auth corresponds to the JSON schema field "auth".
	Auth *ValuesAuth `json:"auth,omitempty" yaml:"auth,omitempty" mapstructure:"auth,omitempty"`

	// Kubernetes cluster domain name
	ClusterDomain string `json:"clusterDomain,omitempty" yaml:"clusterDomain,omitempty" mapstructure:"clusterDomain,omitempty"`

	// Annotations to add to all deployed objects
	CommonAnnotations ValuesCommonAnnotations `json:"commonAnnotations,omitempty" yaml:"commonAnnotations,omitempty" mapstructure:"commonAnnotations,omitempty"`

	// Common configuration to be added into the ConfigMap
	CommonConfiguration string `json:"commonConfiguration,omitempty" yaml:"commonConfiguration,omitempty" mapstructure:"commonConfiguration,omitempty"`

	// Labels to add to all deployed objects
	CommonLabels ValuesCommonLabels `json:"commonLabels,omitempty" yaml:"commonLabels,omitempty" mapstructure:"commonLabels,omitempty"`

	// DiagnosticMode corresponds to the JSON schema field "diagnosticMode".
	DiagnosticMode *ValuesDiagnosticMode `json:"diagnosticMode,omitempty" yaml:"diagnosticMode,omitempty" mapstructure:"diagnosticMode,omitempty"`

	// The name of an existing ConfigMap with your custom configuration for Redis&reg;
	// nodes
	ExistingConfigmap string `json:"existingConfigmap,omitempty" yaml:"existingConfigmap,omitempty" mapstructure:"existingConfigmap,omitempty"`

	// Array of extra objects to deploy with the release
	ExtraDeploy []interface{} `json:"extraDeploy,omitempty" yaml:"extraDeploy,omitempty" mapstructure:"extraDeploy,omitempty"`

	// String to fully override common.names.fullname
	FullnameOverride string `json:"fullnameOverride,omitempty" yaml:"fullnameOverride,omitempty" mapstructure:"fullnameOverride,omitempty"`

	// Global corresponds to the JSON schema field "global".
	Global *ValuesGlobal `json:"global,omitempty" yaml:"global,omitempty" mapstructure:"global,omitempty"`

	// Image corresponds to the JSON schema field "image".
	Image *ValuesImage `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// Override Kubernetes version
	KubeVersion string `json:"kubeVersion,omitempty" yaml:"kubeVersion,omitempty" mapstructure:"kubeVersion,omitempty"`

	// Master corresponds to the JSON schema field "master".
	Master *ValuesMaster `json:"master,omitempty" yaml:"master,omitempty" mapstructure:"master,omitempty"`

	// Metrics corresponds to the JSON schema field "metrics".
	Metrics *ValuesMetrics `json:"metrics,omitempty" yaml:"metrics,omitempty" mapstructure:"metrics,omitempty"`

	// String to partially override common.names.fullname
	NameOverride string `json:"nameOverride,omitempty" yaml:"nameOverride,omitempty" mapstructure:"nameOverride,omitempty"`

	// Failure threshold for internal hostnames resolution
	NameResolutionThreshold float64 `json:"nameResolutionThreshold,omitempty" yaml:"nameResolutionThreshold,omitempty" mapstructure:"nameResolutionThreshold,omitempty"`

	// Timeout seconds between probes for internal hostnames resolution
	NameResolutionTimeout float64 `json:"nameResolutionTimeout,omitempty" yaml:"nameResolutionTimeout,omitempty" mapstructure:"nameResolutionTimeout,omitempty"`

	// String to fully override common.names.namespace
	NamespaceOverride string `json:"namespaceOverride,omitempty" yaml:"namespaceOverride,omitempty" mapstructure:"namespaceOverride,omitempty"`

	// NetworkPolicy corresponds to the JSON schema field "networkPolicy".
	NetworkPolicy *ValuesNetworkPolicy `json:"networkPolicy,omitempty" yaml:"networkPolicy,omitempty" mapstructure:"networkPolicy,omitempty"`

	// Pdb corresponds to the JSON schema field "pdb".
	Pdb *ValuesPdb `json:"pdb,omitempty" yaml:"pdb,omitempty" mapstructure:"pdb,omitempty"`

	// PodSecurityPolicy corresponds to the JSON schema field "podSecurityPolicy".
	PodSecurityPolicy *ValuesPodSecurityPolicy `json:"podSecurityPolicy,omitempty" yaml:"podSecurityPolicy,omitempty" mapstructure:"podSecurityPolicy,omitempty"`

	// Rbac corresponds to the JSON schema field "rbac".
	Rbac *ValuesRbac `json:"rbac,omitempty" yaml:"rbac,omitempty" mapstructure:"rbac,omitempty"`

	// Replica corresponds to the JSON schema field "replica".
	Replica *ValuesReplica `json:"replica,omitempty" yaml:"replica,omitempty" mapstructure:"replica,omitempty"`

	// Annotations to add to secret
	SecretAnnotations ValuesSecretAnnotations `json:"secretAnnotations,omitempty" yaml:"secretAnnotations,omitempty" mapstructure:"secretAnnotations,omitempty"`

	// Sentinel corresponds to the JSON schema field "sentinel".
	Sentinel *ValuesSentinel `json:"sentinel,omitempty" yaml:"sentinel,omitempty" mapstructure:"sentinel,omitempty"`

	// ServiceAccount corresponds to the JSON schema field "serviceAccount".
	ServiceAccount *ValuesServiceAccount `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty" mapstructure:"serviceAccount,omitempty"`

	// ServiceBindings corresponds to the JSON schema field "serviceBindings".
	ServiceBindings *ValuesServiceBindings `json:"serviceBindings,omitempty" yaml:"serviceBindings,omitempty" mapstructure:"serviceBindings,omitempty"`

	// Sysctl corresponds to the JSON schema field "sysctl".
	Sysctl *ValuesSysctl `json:"sysctl,omitempty" yaml:"sysctl,omitempty" mapstructure:"sysctl,omitempty"`

	// Tls corresponds to the JSON schema field "tls".
	Tls *ValuesTls `json:"tls,omitempty" yaml:"tls,omitempty" mapstructure:"tls,omitempty"`

	// UseExternalDNS corresponds to the JSON schema field "useExternalDNS".
	UseExternalDNS *ValuesUseExternalDNS `json:"useExternalDNS,omitempty" yaml:"useExternalDNS,omitempty" mapstructure:"useExternalDNS,omitempty"`

	// Use hostnames internally when announcing replication. If false, the hostname
	// will be resolved to an IP address
	UseHostnames bool `json:"useHostnames,omitempty" yaml:"useHostnames,omitempty" mapstructure:"useHostnames,omitempty"`

	// VolumePermissions corresponds to the JSON schema field "volumePermissions".
	VolumePermissions *ValuesVolumePermissions `json:"volumePermissions,omitempty" yaml:"volumePermissions,omitempty" mapstructure:"volumePermissions,omitempty"`
}

type ValuesAuth struct {
	// Enable password authentication
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// The name of an existing secret with Redis&reg; credentials
	ExistingSecret string `json:"existingSecret,omitempty" yaml:"existingSecret,omitempty" mapstructure:"existingSecret,omitempty"`

	// Password key to be retrieved from existing secret
	ExistingSecretPasswordKey string `json:"existingSecretPasswordKey,omitempty" yaml:"existingSecretPasswordKey,omitempty" mapstructure:"existingSecretPasswordKey,omitempty"`

	// Redis&reg; password
	Password string `json:"password,omitempty" yaml:"password,omitempty" mapstructure:"password,omitempty"`

	// Enable password authentication on sentinels too
	Sentinel bool `json:"sentinel,omitempty" yaml:"sentinel,omitempty" mapstructure:"sentinel,omitempty"`

	// Mount password file from secret
	UsePasswordFileFromSecret bool `json:"usePasswordFileFromSecret,omitempty" yaml:"usePasswordFileFromSecret,omitempty" mapstructure:"usePasswordFileFromSecret,omitempty"`

	// Mount credentials as files instead of using an environment variable
	UsePasswordFiles bool `json:"usePasswordFiles,omitempty" yaml:"usePasswordFiles,omitempty" mapstructure:"usePasswordFiles,omitempty"`
}

// Annotations to add to all deployed objects
type ValuesCommonAnnotations map[string]interface{}

// Labels to add to all deployed objects
type ValuesCommonLabels map[string]interface{}

type ValuesDiagnosticMode struct {
	// Args to override all containers in the deployment
	Args []string `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Command to override all containers in the deployment
	Command []string `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Enable diagnostic mode (all probes will be disabled and the command will be
	// overridden)
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`
}

type ValuesGlobal struct {
	// Global Docker registry secret names as an array
	ImagePullSecrets []interface{} `json:"imagePullSecrets,omitempty" yaml:"imagePullSecrets,omitempty" mapstructure:"imagePullSecrets,omitempty"`

	// Global Docker image registry
	ImageRegistry string `json:"imageRegistry,omitempty" yaml:"imageRegistry,omitempty" mapstructure:"imageRegistry,omitempty"`

	// Redis corresponds to the JSON schema field "redis".
	Redis *ValuesGlobalRedis `json:"redis,omitempty" yaml:"redis,omitempty" mapstructure:"redis,omitempty"`

	// Global StorageClass for Persistent Volume(s)
	StorageClass string `json:"storageClass,omitempty" yaml:"storageClass,omitempty" mapstructure:"storageClass,omitempty"`
}

type ValuesGlobalRedis struct {
	// Global Redis&reg; password (overrides `auth.password`)
	Password string `json:"password,omitempty" yaml:"password,omitempty" mapstructure:"password,omitempty"`
}

type ValuesImage struct {
	// Enable image debug mode
	Debug bool `json:"debug,omitempty" yaml:"debug,omitempty" mapstructure:"debug,omitempty"`

	// Redis&reg; image digest in the way sha256:aa.... Please note this parameter, if
	// set, will override the tag
	Digest string `json:"digest,omitempty" yaml:"digest,omitempty" mapstructure:"digest,omitempty"`

	// Redis&reg; image pull policy
	PullPolicy string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty" mapstructure:"pullPolicy,omitempty"`

	// Redis&reg; image pull secrets
	PullSecrets []interface{} `json:"pullSecrets,omitempty" yaml:"pullSecrets,omitempty" mapstructure:"pullSecrets,omitempty"`

	// Redis&reg; image registry
	Registry string `json:"registry,omitempty" yaml:"registry,omitempty" mapstructure:"registry,omitempty"`

	// Redis&reg; image repository
	Repository string `json:"repository,omitempty" yaml:"repository,omitempty" mapstructure:"repository,omitempty"`
}

type ValuesMaster struct {
	// Affinity for Redis&reg; master pods assignment
	Affinity ValuesMasterAffinity `json:"affinity,omitempty" yaml:"affinity,omitempty" mapstructure:"affinity,omitempty"`

	// Override default container args (useful when using custom images)
	Args []interface{} `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Mount Service Account token in pod
	AutomountServiceAccountToken bool `json:"automountServiceAccountToken,omitempty" yaml:"automountServiceAccountToken,omitempty" mapstructure:"automountServiceAccountToken,omitempty"`

	// Override default container command (useful when using custom images)
	Command []interface{} `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Configuration for Redis&reg; master nodes
	Configuration string `json:"configuration,omitempty" yaml:"configuration,omitempty" mapstructure:"configuration,omitempty"`

	// ContainerPorts corresponds to the JSON schema field "containerPorts".
	ContainerPorts *ValuesMasterContainerPorts `json:"containerPorts,omitempty" yaml:"containerPorts,omitempty" mapstructure:"containerPorts,omitempty"`

	// ContainerSecurityContext corresponds to the JSON schema field
	// "containerSecurityContext".
	ContainerSecurityContext *ValuesMasterContainerSecurityContext `json:"containerSecurityContext,omitempty" yaml:"containerSecurityContext,omitempty" mapstructure:"containerSecurityContext,omitempty"`

	// Number of Redis&reg; master instances to deploy (experimental, requires
	// additional configuration)
	Count float64 `json:"count,omitempty" yaml:"count,omitempty" mapstructure:"count,omitempty"`

	// Custom livenessProbe that overrides the default one
	CustomLivenessProbe ValuesMasterCustomLivenessProbe `json:"customLivenessProbe,omitempty" yaml:"customLivenessProbe,omitempty" mapstructure:"customLivenessProbe,omitempty"`

	// Custom readinessProbe that overrides the default one
	CustomReadinessProbe ValuesMasterCustomReadinessProbe `json:"customReadinessProbe,omitempty" yaml:"customReadinessProbe,omitempty" mapstructure:"customReadinessProbe,omitempty"`

	// Custom startupProbe that overrides the default one
	CustomStartupProbe ValuesMasterCustomStartupProbe `json:"customStartupProbe,omitempty" yaml:"customStartupProbe,omitempty" mapstructure:"customStartupProbe,omitempty"`

	// Array with Redis&reg; commands to disable on master nodes
	DisableCommands []string `json:"disableCommands,omitempty" yaml:"disableCommands,omitempty" mapstructure:"disableCommands,omitempty"`

	// DNS Configuration for Redis&reg; master pod
	DnsConfig ValuesMasterDnsConfig `json:"dnsConfig,omitempty" yaml:"dnsConfig,omitempty" mapstructure:"dnsConfig,omitempty"`

	// DNS Policy for Redis&reg; master pod
	DnsPolicy string `json:"dnsPolicy,omitempty" yaml:"dnsPolicy,omitempty" mapstructure:"dnsPolicy,omitempty"`

	// Whether information about services should be injected into pod's environment
	// variable
	EnableServiceLinks bool `json:"enableServiceLinks,omitempty" yaml:"enableServiceLinks,omitempty" mapstructure:"enableServiceLinks,omitempty"`

	// Array with extra environment variables to add to Redis&reg; master nodes
	ExtraEnvVars []interface{} `json:"extraEnvVars,omitempty" yaml:"extraEnvVars,omitempty" mapstructure:"extraEnvVars,omitempty"`

	// Name of existing ConfigMap containing extra env vars for Redis&reg; master
	// nodes
	ExtraEnvVarsCM string `json:"extraEnvVarsCM,omitempty" yaml:"extraEnvVarsCM,omitempty" mapstructure:"extraEnvVarsCM,omitempty"`

	// Name of existing Secret containing extra env vars for Redis&reg; master nodes
	ExtraEnvVarsSecret string `json:"extraEnvVarsSecret,omitempty" yaml:"extraEnvVarsSecret,omitempty" mapstructure:"extraEnvVarsSecret,omitempty"`

	// Array with additional command line flags for Redis&reg; master
	ExtraFlags []interface{} `json:"extraFlags,omitempty" yaml:"extraFlags,omitempty" mapstructure:"extraFlags,omitempty"`

	// Optionally specify extra list of additional volumeMounts for the Redis&reg;
	// master container(s)
	ExtraVolumeMounts []interface{} `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty" mapstructure:"extraVolumeMounts,omitempty"`

	// Optionally specify extra list of additional volumes for the Redis&reg; master
	// pod(s)
	ExtraVolumes []interface{} `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty" mapstructure:"extraVolumes,omitempty"`

	// Redis&reg; master pods host aliases
	HostAliases []interface{} `json:"hostAliases,omitempty" yaml:"hostAliases,omitempty" mapstructure:"hostAliases,omitempty"`

	// Add additional init containers to the Redis&reg; master pod(s)
	InitContainers []interface{} `json:"initContainers,omitempty" yaml:"initContainers,omitempty" mapstructure:"initContainers,omitempty"`

	// Use either Deployment, StatefulSet (default) or DaemonSet
	Kind string `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// for the Redis&reg; master container(s) to automate configuration before or
	// after startup
	LifecycleHooks ValuesMasterLifecycleHooks `json:"lifecycleHooks,omitempty" yaml:"lifecycleHooks,omitempty" mapstructure:"lifecycleHooks,omitempty"`

	// LivenessProbe corresponds to the JSON schema field "livenessProbe".
	LivenessProbe *ValuesMasterLivenessProbe `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty" mapstructure:"livenessProbe,omitempty"`

	// How many seconds a pod needs to be ready before killing the next, during update
	MinReadySeconds float64 `json:"minReadySeconds,omitempty" yaml:"minReadySeconds,omitempty" mapstructure:"minReadySeconds,omitempty"`

	// NodeAffinityPreset corresponds to the JSON schema field "nodeAffinityPreset".
	NodeAffinityPreset *ValuesMasterNodeAffinityPreset `json:"nodeAffinityPreset,omitempty" yaml:"nodeAffinityPreset,omitempty" mapstructure:"nodeAffinityPreset,omitempty"`

	// Node labels for Redis&reg; master pods assignment
	NodeSelector ValuesMasterNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty" mapstructure:"nodeSelector,omitempty"`

	// Persistence corresponds to the JSON schema field "persistence".
	Persistence *ValuesMasterPersistence `json:"persistence,omitempty" yaml:"persistence,omitempty" mapstructure:"persistence,omitempty"`

	// PersistentVolumeClaimRetentionPolicy corresponds to the JSON schema field
	// "persistentVolumeClaimRetentionPolicy".
	PersistentVolumeClaimRetentionPolicy *ValuesMasterPersistentVolumeClaimRetentionPolicy `json:"persistentVolumeClaimRetentionPolicy,omitempty" yaml:"persistentVolumeClaimRetentionPolicy,omitempty" mapstructure:"persistentVolumeClaimRetentionPolicy,omitempty"`

	// Pod affinity preset. Ignored if `master.affinity` is set. Allowed values:
	// `soft` or `hard`
	PodAffinityPreset string `json:"podAffinityPreset,omitempty" yaml:"podAffinityPreset,omitempty" mapstructure:"podAffinityPreset,omitempty"`

	// Annotations for Redis&reg; master pods
	PodAnnotations ValuesMasterPodAnnotations `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty" mapstructure:"podAnnotations,omitempty"`

	// Pod anti-affinity preset. Ignored if `master.affinity` is set. Allowed values:
	// `soft` or `hard`
	PodAntiAffinityPreset string `json:"podAntiAffinityPreset,omitempty" yaml:"podAntiAffinityPreset,omitempty" mapstructure:"podAntiAffinityPreset,omitempty"`

	// Extra labels for Redis&reg; master pods
	PodLabels ValuesMasterPodLabels `json:"podLabels,omitempty" yaml:"podLabels,omitempty" mapstructure:"podLabels,omitempty"`

	// PodSecurityContext corresponds to the JSON schema field "podSecurityContext".
	PodSecurityContext *ValuesMasterPodSecurityContext `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty" mapstructure:"podSecurityContext,omitempty"`

	// Additional commands to run prior to starting Redis&reg; master
	PreExecCmds []interface{} `json:"preExecCmds,omitempty" yaml:"preExecCmds,omitempty" mapstructure:"preExecCmds,omitempty"`

	// Redis&reg; master pods' priorityClassName
	PriorityClassName string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty" mapstructure:"priorityClassName,omitempty"`

	// ReadinessProbe corresponds to the JSON schema field "readinessProbe".
	ReadinessProbe *ValuesMasterReadinessProbe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty" mapstructure:"readinessProbe,omitempty"`

	// Set container requests and limits for different resources like CPU or memory
	// (essential for production workloads)
	Resources ValuesMasterResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Set container resources according to one common preset (allowed values: none,
	// nano, small, medium, large, xlarge, 2xlarge). This is ignored if
	// master.resources is set (master.resources is recommended for production).
	ResourcesPreset string `json:"resourcesPreset,omitempty" yaml:"resourcesPreset,omitempty" mapstructure:"resourcesPreset,omitempty"`

	// Alternate scheduler for Redis&reg; master pods
	SchedulerName string `json:"schedulerName,omitempty" yaml:"schedulerName,omitempty" mapstructure:"schedulerName,omitempty"`

	// Service corresponds to the JSON schema field "service".
	Service *ValuesMasterService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`

	// ServiceAccount corresponds to the JSON schema field "serviceAccount".
	ServiceAccount *ValuesMasterServiceAccount `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty" mapstructure:"serviceAccount,omitempty"`

	// Share a single process namespace between all of the containers in Redis&reg;
	// master pods
	ShareProcessNamespace bool `json:"shareProcessNamespace,omitempty" yaml:"shareProcessNamespace,omitempty" mapstructure:"shareProcessNamespace,omitempty"`

	// Add additional sidecar containers to the Redis&reg; master pod(s)
	Sidecars []interface{} `json:"sidecars,omitempty" yaml:"sidecars,omitempty" mapstructure:"sidecars,omitempty"`

	// StartupProbe corresponds to the JSON schema field "startupProbe".
	StartupProbe *ValuesMasterStartupProbe `json:"startupProbe,omitempty" yaml:"startupProbe,omitempty" mapstructure:"startupProbe,omitempty"`

	// Integer setting the termination grace period for the redis-master pods
	TerminationGracePeriodSeconds float64 `json:"terminationGracePeriodSeconds,omitempty" yaml:"terminationGracePeriodSeconds,omitempty" mapstructure:"terminationGracePeriodSeconds,omitempty"`

	// Tolerations for Redis&reg; master pods assignment
	Tolerations []interface{} `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`

	// Spread Constraints for Redis&reg; master pod assignment
	TopologySpreadConstraints []interface{} `json:"topologySpreadConstraints,omitempty" yaml:"topologySpreadConstraints,omitempty" mapstructure:"topologySpreadConstraints,omitempty"`

	// UpdateStrategy corresponds to the JSON schema field "updateStrategy".
	UpdateStrategy *ValuesMasterUpdateStrategy `json:"updateStrategy,omitempty" yaml:"updateStrategy,omitempty" mapstructure:"updateStrategy,omitempty"`
}

// Affinity for Redis&reg; master pods assignment
type ValuesMasterAffinity map[string]interface{}

type ValuesMasterContainerPorts struct {
	// Container port to open on Redis&reg; master nodes
	Redis float64 `json:"redis,omitempty" yaml:"redis,omitempty" mapstructure:"redis,omitempty"`
}

type ValuesMasterContainerSecurityContext struct {
	// Is it possible to escalate Redis&reg; pod(s) privileges
	AllowPrivilegeEscalation bool `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty" mapstructure:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *ValuesMasterContainerSecurityContextCapabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty" mapstructure:"capabilities,omitempty"`

	// Enabled Redis&reg; master containers' Security Context
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Set container's Security Context read-only root filesystem
	ReadOnlyRootFilesystem bool `json:"readOnlyRootFilesystem,omitempty" yaml:"readOnlyRootFilesystem,omitempty" mapstructure:"readOnlyRootFilesystem,omitempty"`

	// Set Redis&reg; master containers' Security Context runAsGroup
	RunAsGroup float64 `json:"runAsGroup,omitempty" yaml:"runAsGroup,omitempty" mapstructure:"runAsGroup,omitempty"`

	// Set Redis&reg; master containers' Security Context runAsNonRoot
	RunAsNonRoot bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty" mapstructure:"runAsNonRoot,omitempty"`

	// Set Redis&reg; master containers' Security Context runAsUser
	RunAsUser float64 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *ValuesMasterContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty" mapstructure:"seccompProfile,omitempty"`
}

type ValuesMasterContainerSecurityContextCapabilities struct {
	// Set Redis&reg; master containers' Security Context capabilities to drop
	Drop []string `json:"drop,omitempty" yaml:"drop,omitempty" mapstructure:"drop,omitempty"`
}

type ValuesMasterContainerSecurityContextSeccompProfile struct {
	// Set Redis&reg; master containers' Security Context seccompProfile
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// Custom livenessProbe that overrides the default one
type ValuesMasterCustomLivenessProbe map[string]interface{}

// Custom readinessProbe that overrides the default one
type ValuesMasterCustomReadinessProbe map[string]interface{}

// Custom startupProbe that overrides the default one
type ValuesMasterCustomStartupProbe map[string]interface{}

// DNS Configuration for Redis&reg; master pod
type ValuesMasterDnsConfig map[string]interface{}

// for the Redis&reg; master container(s) to automate configuration before or after
// startup
type ValuesMasterLifecycleHooks map[string]interface{}

type ValuesMasterLivenessProbe struct {
	// Enable livenessProbe on Redis&reg; master nodes
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for livenessProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for livenessProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for livenessProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for livenessProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for livenessProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

type ValuesMasterNodeAffinityPreset struct {
	// Node label key to match. Ignored if `master.affinity` is set
	Key string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Node affinity preset type. Ignored if `master.affinity` is set. Allowed values:
	// `soft` or `hard`
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// Node label values to match. Ignored if `master.affinity` is set
	Values []interface{} `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// Node labels for Redis&reg; master pods assignment
type ValuesMasterNodeSelector map[string]interface{}

type ValuesMasterPersistence struct {
	// Persistent Volume access modes
	AccessModes []string `json:"accessModes,omitempty" yaml:"accessModes,omitempty" mapstructure:"accessModes,omitempty"`

	// Additional custom annotations for the PVC
	Annotations ValuesMasterPersistenceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Custom PVC data source
	DataSource ValuesMasterPersistenceDataSource `json:"dataSource,omitempty" yaml:"dataSource,omitempty" mapstructure:"dataSource,omitempty"`

	// Enable persistence on Redis&reg; master nodes using Persistent Volume Claims
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Use a existing PVC which must be created manually before bound
	ExistingClaim string `json:"existingClaim,omitempty" yaml:"existingClaim,omitempty" mapstructure:"existingClaim,omitempty"`

	// Additional custom labels for the PVC
	Labels ValuesMasterPersistenceLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Provide a medium for `emptyDir` volumes.
	Medium string `json:"medium,omitempty" yaml:"medium,omitempty" mapstructure:"medium,omitempty"`

	// The path the volume will be mounted at on Redis&reg; master containers
	Path string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// Additional labels to match for the PVC
	Selector ValuesMasterPersistenceSelector `json:"selector,omitempty" yaml:"selector,omitempty" mapstructure:"selector,omitempty"`

	// Persistent Volume size
	Size string `json:"size,omitempty" yaml:"size,omitempty" mapstructure:"size,omitempty"`

	// Set this to enable a size limit for `emptyDir` volumes.
	SizeLimit string `json:"sizeLimit,omitempty" yaml:"sizeLimit,omitempty" mapstructure:"sizeLimit,omitempty"`

	// Persistent Volume storage class
	StorageClass string `json:"storageClass,omitempty" yaml:"storageClass,omitempty" mapstructure:"storageClass,omitempty"`

	// The subdirectory of the volume to mount on Redis&reg; master containers
	SubPath string `json:"subPath,omitempty" yaml:"subPath,omitempty" mapstructure:"subPath,omitempty"`

	// Used to construct the subPath subdirectory of the volume to mount on Redis&reg;
	// master containers
	SubPathExpr string `json:"subPathExpr,omitempty" yaml:"subPathExpr,omitempty" mapstructure:"subPathExpr,omitempty"`
}

// Additional custom annotations for the PVC
type ValuesMasterPersistenceAnnotations map[string]interface{}

// Custom PVC data source
type ValuesMasterPersistenceDataSource map[string]interface{}

// Additional custom labels for the PVC
type ValuesMasterPersistenceLabels map[string]interface{}

// Additional labels to match for the PVC
type ValuesMasterPersistenceSelector map[string]interface{}

type ValuesMasterPersistentVolumeClaimRetentionPolicy struct {
	// Controls if and how PVCs are deleted during the lifecycle of a StatefulSet
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Volume retention behavior that applies when the StatefulSet is deleted
	WhenDeleted string `json:"whenDeleted,omitempty" yaml:"whenDeleted,omitempty" mapstructure:"whenDeleted,omitempty"`

	// Volume retention behavior when the replica count of the StatefulSet is reduced
	WhenScaled string `json:"whenScaled,omitempty" yaml:"whenScaled,omitempty" mapstructure:"whenScaled,omitempty"`
}

// Annotations for Redis&reg; master pods
type ValuesMasterPodAnnotations map[string]interface{}

// Extra labels for Redis&reg; master pods
type ValuesMasterPodLabels map[string]interface{}

type ValuesMasterPodSecurityContext struct {
	// Enabled Redis&reg; master pods' Security Context
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Set Redis&reg; master pod's Security Context fsGroup
	FsGroup float64 `json:"fsGroup,omitempty" yaml:"fsGroup,omitempty" mapstructure:"fsGroup,omitempty"`

	// Set filesystem group change policy
	FsGroupChangePolicy string `json:"fsGroupChangePolicy,omitempty" yaml:"fsGroupChangePolicy,omitempty" mapstructure:"fsGroupChangePolicy,omitempty"`

	// Set filesystem extra groups
	SupplementalGroups []interface{} `json:"supplementalGroups,omitempty" yaml:"supplementalGroups,omitempty" mapstructure:"supplementalGroups,omitempty"`

	// Set kernel settings using the sysctl interface
	Sysctls []interface{} `json:"sysctls,omitempty" yaml:"sysctls,omitempty" mapstructure:"sysctls,omitempty"`
}

type ValuesMasterReadinessProbe struct {
	// Enable readinessProbe on Redis&reg; master nodes
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for readinessProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for readinessProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for readinessProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for readinessProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for readinessProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

// Set container requests and limits for different resources like CPU or memory
// (essential for production workloads)
type ValuesMasterResources map[string]interface{}

type ValuesMasterService struct {
	// Additional custom annotations for Redis&reg; master service
	Annotations ValuesMasterServiceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Redis&reg; master service Cluster IP
	ClusterIP string `json:"clusterIP,omitempty" yaml:"clusterIP,omitempty" mapstructure:"clusterIP,omitempty"`

	// Redis&reg; master service External IPs
	ExternalIPs []interface{} `json:"externalIPs,omitempty" yaml:"externalIPs,omitempty" mapstructure:"externalIPs,omitempty"`

	// Redis&reg; master service external traffic policy
	ExternalTrafficPolicy string `json:"externalTrafficPolicy,omitempty" yaml:"externalTrafficPolicy,omitempty" mapstructure:"externalTrafficPolicy,omitempty"`

	// Extra ports to expose (normally used with the `sidecar` value)
	ExtraPorts []interface{} `json:"extraPorts,omitempty" yaml:"extraPorts,omitempty" mapstructure:"extraPorts,omitempty"`

	// Redis&reg; master service internal traffic policy (requires Kubernetes v1.22 or
	// greater to be usable)
	InternalTrafficPolicy string `json:"internalTrafficPolicy,omitempty" yaml:"internalTrafficPolicy,omitempty" mapstructure:"internalTrafficPolicy,omitempty"`

	// master service Load Balancer class if service type is `LoadBalancer` (optional,
	// cloud specific)
	LoadBalancerClass string `json:"loadBalancerClass,omitempty" yaml:"loadBalancerClass,omitempty" mapstructure:"loadBalancerClass,omitempty"`

	// Redis&reg; master service Load Balancer IP
	LoadBalancerIP string `json:"loadBalancerIP,omitempty" yaml:"loadBalancerIP,omitempty" mapstructure:"loadBalancerIP,omitempty"`

	// Redis&reg; master service Load Balancer sources
	LoadBalancerSourceRanges []interface{} `json:"loadBalancerSourceRanges,omitempty" yaml:"loadBalancerSourceRanges,omitempty" mapstructure:"loadBalancerSourceRanges,omitempty"`

	// NodePorts corresponds to the JSON schema field "nodePorts".
	NodePorts *ValuesMasterServiceNodePorts `json:"nodePorts,omitempty" yaml:"nodePorts,omitempty" mapstructure:"nodePorts,omitempty"`

	// Ports corresponds to the JSON schema field "ports".
	Ports *ValuesMasterServicePorts `json:"ports,omitempty" yaml:"ports,omitempty" mapstructure:"ports,omitempty"`

	// Session Affinity for Kubernetes service, can be "None" or "ClientIP"
	SessionAffinity string `json:"sessionAffinity,omitempty" yaml:"sessionAffinity,omitempty" mapstructure:"sessionAffinity,omitempty"`

	// Additional settings for the sessionAffinity
	SessionAffinityConfig ValuesMasterServiceSessionAffinityConfig `json:"sessionAffinityConfig,omitempty" yaml:"sessionAffinityConfig,omitempty" mapstructure:"sessionAffinityConfig,omitempty"`

	// Redis&reg; master service type
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type ValuesMasterServiceAccount struct {
	// Additional custom annotations for the ServiceAccount
	Annotations ValuesMasterServiceAccountAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Whether to auto mount the service account token
	AutomountServiceAccountToken bool `json:"automountServiceAccountToken,omitempty" yaml:"automountServiceAccountToken,omitempty" mapstructure:"automountServiceAccountToken,omitempty"`

	// Specifies whether a ServiceAccount should be created
	Create bool `json:"create,omitempty" yaml:"create,omitempty" mapstructure:"create,omitempty"`

	// The name of the ServiceAccount to use.
	Name string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// Additional custom annotations for the ServiceAccount
type ValuesMasterServiceAccountAnnotations map[string]interface{}

// Additional custom annotations for Redis&reg; master service
type ValuesMasterServiceAnnotations map[string]interface{}

type ValuesMasterServiceNodePorts struct {
	// Node port for Redis&reg; master
	Redis string `json:"redis,omitempty" yaml:"redis,omitempty" mapstructure:"redis,omitempty"`
}

type ValuesMasterServicePorts struct {
	// Redis&reg; master service port
	Redis float64 `json:"redis,omitempty" yaml:"redis,omitempty" mapstructure:"redis,omitempty"`
}

// Additional settings for the sessionAffinity
type ValuesMasterServiceSessionAffinityConfig map[string]interface{}

type ValuesMasterStartupProbe struct {
	// Enable startupProbe on Redis&reg; master nodes
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for startupProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for startupProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for startupProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for startupProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for startupProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

type ValuesMasterUpdateStrategy struct {
	// Redis&reg; master statefulset strategy type
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type ValuesMetrics struct {
	// Override default metrics container init command (useful when using custom
	// images)
	Command []interface{} `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// ContainerPorts corresponds to the JSON schema field "containerPorts".
	ContainerPorts *ValuesMetricsContainerPorts `json:"containerPorts,omitempty" yaml:"containerPorts,omitempty" mapstructure:"containerPorts,omitempty"`

	// ContainerSecurityContext corresponds to the JSON schema field
	// "containerSecurityContext".
	ContainerSecurityContext *ValuesMetricsContainerSecurityContext `json:"containerSecurityContext,omitempty" yaml:"containerSecurityContext,omitempty" mapstructure:"containerSecurityContext,omitempty"`

	// Custom livenessProbe that overrides the default one
	CustomLivenessProbe ValuesMetricsCustomLivenessProbe `json:"customLivenessProbe,omitempty" yaml:"customLivenessProbe,omitempty" mapstructure:"customLivenessProbe,omitempty"`

	// Custom readinessProbe that overrides the default one
	CustomReadinessProbe ValuesMetricsCustomReadinessProbe `json:"customReadinessProbe,omitempty" yaml:"customReadinessProbe,omitempty" mapstructure:"customReadinessProbe,omitempty"`

	// Custom startupProbe that overrides the default one
	CustomStartupProbe ValuesMetricsCustomStartupProbe `json:"customStartupProbe,omitempty" yaml:"customStartupProbe,omitempty" mapstructure:"customStartupProbe,omitempty"`

	// Start a sidecar prometheus exporter to expose Redis&reg; metrics
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Extra arguments for Redis&reg; exporter, for example:
	ExtraArgs ValuesMetricsExtraArgs `json:"extraArgs,omitempty" yaml:"extraArgs,omitempty" mapstructure:"extraArgs,omitempty"`

	// Array with extra environment variables to add to Redis&reg; exporter
	ExtraEnvVars []interface{} `json:"extraEnvVars,omitempty" yaml:"extraEnvVars,omitempty" mapstructure:"extraEnvVars,omitempty"`

	// Optionally specify extra list of additional volumeMounts for the Redis&reg;
	// metrics sidecar
	ExtraVolumeMounts []interface{} `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty" mapstructure:"extraVolumeMounts,omitempty"`

	// Optionally specify extra list of additional volumes for the Redis&reg; metrics
	// sidecar
	ExtraVolumes []interface{} `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty" mapstructure:"extraVolumes,omitempty"`

	// Image corresponds to the JSON schema field "image".
	Image *ValuesMetricsImage `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// LivenessProbe corresponds to the JSON schema field "livenessProbe".
	LivenessProbe *ValuesMetricsLivenessProbe `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty" mapstructure:"livenessProbe,omitempty"`

	// Extra labels for Redis&reg; exporter pods
	PodLabels ValuesMetricsPodLabels `json:"podLabels,omitempty" yaml:"podLabels,omitempty" mapstructure:"podLabels,omitempty"`

	// PodMonitor corresponds to the JSON schema field "podMonitor".
	PodMonitor *ValuesMetricsPodMonitor `json:"podMonitor,omitempty" yaml:"podMonitor,omitempty" mapstructure:"podMonitor,omitempty"`

	// PrometheusRule corresponds to the JSON schema field "prometheusRule".
	PrometheusRule *ValuesMetricsPrometheusRule `json:"prometheusRule,omitempty" yaml:"prometheusRule,omitempty" mapstructure:"prometheusRule,omitempty"`

	// ReadinessProbe corresponds to the JSON schema field "readinessProbe".
	ReadinessProbe *ValuesMetricsReadinessProbe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty" mapstructure:"readinessProbe,omitempty"`

	// A way to specify an alternative Redis&reg; hostname
	RedisTargetHost string `json:"redisTargetHost,omitempty" yaml:"redisTargetHost,omitempty" mapstructure:"redisTargetHost,omitempty"`

	// Set container requests and limits for different resources like CPU or memory
	// (essential for production workloads)
	Resources ValuesMetricsResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Set container resources according to one common preset (allowed values: none,
	// nano, small, medium, large, xlarge, 2xlarge). This is ignored if
	// metrics.resources is set (metrics.resources is recommended for production).
	ResourcesPreset string `json:"resourcesPreset,omitempty" yaml:"resourcesPreset,omitempty" mapstructure:"resourcesPreset,omitempty"`

	// Service corresponds to the JSON schema field "service".
	Service *ValuesMetricsService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`

	// ServiceMonitor corresponds to the JSON schema field "serviceMonitor".
	ServiceMonitor *ValuesMetricsServiceMonitor `json:"serviceMonitor,omitempty" yaml:"serviceMonitor,omitempty" mapstructure:"serviceMonitor,omitempty"`

	// StartupProbe corresponds to the JSON schema field "startupProbe".
	StartupProbe *ValuesMetricsStartupProbe `json:"startupProbe,omitempty" yaml:"startupProbe,omitempty" mapstructure:"startupProbe,omitempty"`
}

type ValuesMetricsContainerPorts struct {
	// Metrics HTTP container port
	Http float64 `json:"http,omitempty" yaml:"http,omitempty" mapstructure:"http,omitempty"`
}

type ValuesMetricsContainerSecurityContext struct {
	// Set Redis&reg; exporter containers' Security Context allowPrivilegeEscalation
	AllowPrivilegeEscalation bool `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty" mapstructure:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *ValuesMetricsContainerSecurityContextCapabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty" mapstructure:"capabilities,omitempty"`

	// Enabled Redis&reg; exporter containers' Security Context
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Set container's Security Context read-only root filesystem
	ReadOnlyRootFilesystem bool `json:"readOnlyRootFilesystem,omitempty" yaml:"readOnlyRootFilesystem,omitempty" mapstructure:"readOnlyRootFilesystem,omitempty"`

	// Set Redis&reg; exporter containers' Security Context runAsGroup
	RunAsGroup float64 `json:"runAsGroup,omitempty" yaml:"runAsGroup,omitempty" mapstructure:"runAsGroup,omitempty"`

	// Set Redis&reg; exporter containers' Security Context runAsNonRoot
	RunAsNonRoot bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty" mapstructure:"runAsNonRoot,omitempty"`

	// Set Redis&reg; exporter containers' Security Context runAsUser
	RunAsUser float64 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *ValuesMetricsContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty" mapstructure:"seccompProfile,omitempty"`
}

type ValuesMetricsContainerSecurityContextCapabilities struct {
	// Set Redis&reg; exporter containers' Security Context capabilities to drop
	Drop []string `json:"drop,omitempty" yaml:"drop,omitempty" mapstructure:"drop,omitempty"`
}

type ValuesMetricsContainerSecurityContextSeccompProfile struct {
	// Set Redis&reg; exporter containers' Security Context seccompProfile
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// Custom livenessProbe that overrides the default one
type ValuesMetricsCustomLivenessProbe map[string]interface{}

// Custom readinessProbe that overrides the default one
type ValuesMetricsCustomReadinessProbe map[string]interface{}

// Custom startupProbe that overrides the default one
type ValuesMetricsCustomStartupProbe map[string]interface{}

// Extra arguments for Redis&reg; exporter, for example:
type ValuesMetricsExtraArgs map[string]interface{}

type ValuesMetricsImage struct {
	// Redis&reg; Exporter image digest in the way sha256:aa.... Please note this
	// parameter, if set, will override the tag
	Digest string `json:"digest,omitempty" yaml:"digest,omitempty" mapstructure:"digest,omitempty"`

	// Redis&reg; Exporter image pull policy
	PullPolicy string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty" mapstructure:"pullPolicy,omitempty"`

	// Redis&reg; Exporter image pull secrets
	PullSecrets []interface{} `json:"pullSecrets,omitempty" yaml:"pullSecrets,omitempty" mapstructure:"pullSecrets,omitempty"`

	// Redis&reg; Exporter image registry
	Registry string `json:"registry,omitempty" yaml:"registry,omitempty" mapstructure:"registry,omitempty"`

	// Redis&reg; Exporter image repository
	Repository string `json:"repository,omitempty" yaml:"repository,omitempty" mapstructure:"repository,omitempty"`
}

type ValuesMetricsLivenessProbe struct {
	// Enable livenessProbe on Redis&reg; replicas nodes
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for livenessProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for livenessProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for livenessProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for livenessProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for livenessProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

// Extra labels for Redis&reg; exporter pods
type ValuesMetricsPodLabels map[string]interface{}

type ValuesMetricsPodMonitor struct {
	// Additional endpoints to scrape (e.g sentinel)
	AdditionalEndpoints []interface{} `json:"additionalEndpoints,omitempty" yaml:"additionalEndpoints,omitempty" mapstructure:"additionalEndpoints,omitempty"`

	// Additional labels that can be used so PodMonitor resource(s) can be discovered
	// by Prometheus
	AdditionalLabels ValuesMetricsPodMonitorAdditionalLabels `json:"additionalLabels,omitempty" yaml:"additionalLabels,omitempty" mapstructure:"additionalLabels,omitempty"`

	// Create PodMonitor resource(s) for scraping metrics using PrometheusOperator
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Specify honorLabels parameter to add the scrape endpoint
	HonorLabels bool `json:"honorLabels,omitempty" yaml:"honorLabels,omitempty" mapstructure:"honorLabels,omitempty"`

	// The interval at which metrics should be scraped
	Interval string `json:"interval,omitempty" yaml:"interval,omitempty" mapstructure:"interval,omitempty"`

	// Metrics RelabelConfigs to apply to samples before ingestion.
	MetricRelabelings []interface{} `json:"metricRelabelings,omitempty" yaml:"metricRelabelings,omitempty" mapstructure:"metricRelabelings,omitempty"`

	// The namespace in which the PodMonitor will be created
	Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// Labels from the Kubernetes pod to be transferred to the created metrics
	PodTargetLabels []interface{} `json:"podTargetLabels,omitempty" yaml:"podTargetLabels,omitempty" mapstructure:"podTargetLabels,omitempty"`

	// the pod port to scrape metrics from
	Port string `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`

	// Metrics RelabelConfigs to apply to samples before scraping.
	Relabellings []interface{} `json:"relabellings,omitempty" yaml:"relabellings,omitempty" mapstructure:"relabellings,omitempty"`

	// Limit of how many samples should be scraped from every Pod
	SampleLimit bool `json:"sampleLimit,omitempty" yaml:"sampleLimit,omitempty" mapstructure:"sampleLimit,omitempty"`

	// The timeout after which the scrape is ended
	ScrapeTimeout string `json:"scrapeTimeout,omitempty" yaml:"scrapeTimeout,omitempty" mapstructure:"scrapeTimeout,omitempty"`

	// Limit of how many targets should be scraped
	TargetLimit bool `json:"targetLimit,omitempty" yaml:"targetLimit,omitempty" mapstructure:"targetLimit,omitempty"`
}

// Additional labels that can be used so PodMonitor resource(s) can be discovered
// by Prometheus
type ValuesMetricsPodMonitorAdditionalLabels map[string]interface{}

type ValuesMetricsPrometheusRule struct {
	// Additional labels for the prometheusRule
	AdditionalLabels ValuesMetricsPrometheusRuleAdditionalLabels `json:"additionalLabels,omitempty" yaml:"additionalLabels,omitempty" mapstructure:"additionalLabels,omitempty"`

	// Create a custom prometheusRule Resource for scraping metrics using
	// PrometheusOperator
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// The namespace in which the prometheusRule will be created
	Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// Custom Prometheus rules
	Rules []interface{} `json:"rules,omitempty" yaml:"rules,omitempty" mapstructure:"rules,omitempty"`
}

// Additional labels for the prometheusRule
type ValuesMetricsPrometheusRuleAdditionalLabels map[string]interface{}

type ValuesMetricsReadinessProbe struct {
	// Enable readinessProbe on Redis&reg; replicas nodes
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for readinessProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for readinessProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for readinessProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for readinessProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for readinessProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

// Set container requests and limits for different resources like CPU or memory
// (essential for production workloads)
type ValuesMetricsResources map[string]interface{}

type ValuesMetricsService struct {
	// Additional custom annotations for Redis&reg; exporter service
	Annotations ValuesMetricsServiceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Redis&reg; exporter service Cluster IP
	ClusterIP string `json:"clusterIP,omitempty" yaml:"clusterIP,omitempty" mapstructure:"clusterIP,omitempty"`

	// Create Service resource(s) for scraping metrics using PrometheusOperator
	// ServiceMonitor, can be disabled when using a PodMonitor
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Redis&reg; exporter service external traffic policy
	ExternalTrafficPolicy string `json:"externalTrafficPolicy,omitempty" yaml:"externalTrafficPolicy,omitempty" mapstructure:"externalTrafficPolicy,omitempty"`

	// Extra ports to expose (normally used with the `sidecar` value)
	ExtraPorts []interface{} `json:"extraPorts,omitempty" yaml:"extraPorts,omitempty" mapstructure:"extraPorts,omitempty"`

	// exporter service Load Balancer class if service type is `LoadBalancer`
	// (optional, cloud specific)
	LoadBalancerClass string `json:"loadBalancerClass,omitempty" yaml:"loadBalancerClass,omitempty" mapstructure:"loadBalancerClass,omitempty"`

	// Redis&reg; exporter service Load Balancer IP
	LoadBalancerIP string `json:"loadBalancerIP,omitempty" yaml:"loadBalancerIP,omitempty" mapstructure:"loadBalancerIP,omitempty"`

	// Redis&reg; exporter service Load Balancer sources
	LoadBalancerSourceRanges []interface{} `json:"loadBalancerSourceRanges,omitempty" yaml:"loadBalancerSourceRanges,omitempty" mapstructure:"loadBalancerSourceRanges,omitempty"`

	// Ports corresponds to the JSON schema field "ports".
	Ports *ValuesMetricsServicePorts `json:"ports,omitempty" yaml:"ports,omitempty" mapstructure:"ports,omitempty"`

	// Redis&reg; exporter service type
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// Additional custom annotations for Redis&reg; exporter service
type ValuesMetricsServiceAnnotations map[string]interface{}

type ValuesMetricsServiceMonitor struct {
	// Additional endpoints to scrape (e.g sentinel)
	AdditionalEndpoints []interface{} `json:"additionalEndpoints,omitempty" yaml:"additionalEndpoints,omitempty" mapstructure:"additionalEndpoints,omitempty"`

	// Additional labels that can be used so ServiceMonitor resource(s) can be
	// discovered by Prometheus
	AdditionalLabels ValuesMetricsServiceMonitorAdditionalLabels `json:"additionalLabels,omitempty" yaml:"additionalLabels,omitempty" mapstructure:"additionalLabels,omitempty"`

	// Create ServiceMonitor resource(s) for scraping metrics using PrometheusOperator
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Specify honorLabels parameter to add the scrape endpoint
	HonorLabels bool `json:"honorLabels,omitempty" yaml:"honorLabels,omitempty" mapstructure:"honorLabels,omitempty"`

	// The interval at which metrics should be scraped
	Interval string `json:"interval,omitempty" yaml:"interval,omitempty" mapstructure:"interval,omitempty"`

	// Metrics RelabelConfigs to apply to samples before ingestion.
	MetricRelabelings []interface{} `json:"metricRelabelings,omitempty" yaml:"metricRelabelings,omitempty" mapstructure:"metricRelabelings,omitempty"`

	// The namespace in which the ServiceMonitor will be created
	Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// Labels from the Kubernetes pod to be transferred to the created metrics
	PodTargetLabels []interface{} `json:"podTargetLabels,omitempty" yaml:"podTargetLabels,omitempty" mapstructure:"podTargetLabels,omitempty"`

	// the service port to scrape metrics from
	Port string `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`

	// Metrics RelabelConfigs to apply to samples before scraping.
	Relabellings []interface{} `json:"relabellings,omitempty" yaml:"relabellings,omitempty" mapstructure:"relabellings,omitempty"`

	// Limit of how many samples should be scraped from every Pod
	SampleLimit bool `json:"sampleLimit,omitempty" yaml:"sampleLimit,omitempty" mapstructure:"sampleLimit,omitempty"`

	// The timeout after which the scrape is ended
	ScrapeTimeout string `json:"scrapeTimeout,omitempty" yaml:"scrapeTimeout,omitempty" mapstructure:"scrapeTimeout,omitempty"`

	// Limit of how many targets should be scraped
	TargetLimit bool `json:"targetLimit,omitempty" yaml:"targetLimit,omitempty" mapstructure:"targetLimit,omitempty"`
}

// Additional labels that can be used so ServiceMonitor resource(s) can be
// discovered by Prometheus
type ValuesMetricsServiceMonitorAdditionalLabels map[string]interface{}

type ValuesMetricsServicePorts struct {
	// Redis&reg; exporter service port
	Http float64 `json:"http,omitempty" yaml:"http,omitempty" mapstructure:"http,omitempty"`
}

type ValuesMetricsStartupProbe struct {
	// Enable startupProbe on Redis&reg; replicas nodes
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for startupProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for startupProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for startupProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for startupProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for startupProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

type ValuesNetworkPolicy struct {
	// Don't require client label for connections
	AllowExternal bool `json:"allowExternal,omitempty" yaml:"allowExternal,omitempty" mapstructure:"allowExternal,omitempty"`

	// Allow the pod to access any range of port and all destinations.
	AllowExternalEgress bool `json:"allowExternalEgress,omitempty" yaml:"allowExternalEgress,omitempty" mapstructure:"allowExternalEgress,omitempty"`

	// Enable creation of NetworkPolicy resources
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Add extra egress rules to the NetworkPolicy
	ExtraEgress []interface{} `json:"extraEgress,omitempty" yaml:"extraEgress,omitempty" mapstructure:"extraEgress,omitempty"`

	// Add extra ingress rules to the NetworkPolicy
	ExtraIngress []interface{} `json:"extraIngress,omitempty" yaml:"extraIngress,omitempty" mapstructure:"extraIngress,omitempty"`

	// Labels to match to allow traffic from other namespaces
	IngressNSMatchLabels ValuesNetworkPolicyIngressNSMatchLabels `json:"ingressNSMatchLabels,omitempty" yaml:"ingressNSMatchLabels,omitempty" mapstructure:"ingressNSMatchLabels,omitempty"`

	// Pod labels to match to allow traffic from other namespaces
	IngressNSPodMatchLabels ValuesNetworkPolicyIngressNSPodMatchLabels `json:"ingressNSPodMatchLabels,omitempty" yaml:"ingressNSPodMatchLabels,omitempty" mapstructure:"ingressNSPodMatchLabels,omitempty"`

	// Metrics corresponds to the JSON schema field "metrics".
	Metrics *ValuesNetworkPolicyMetrics `json:"metrics,omitempty" yaml:"metrics,omitempty" mapstructure:"metrics,omitempty"`
}

// Labels to match to allow traffic from other namespaces
type ValuesNetworkPolicyIngressNSMatchLabels map[string]interface{}

// Pod labels to match to allow traffic from other namespaces
type ValuesNetworkPolicyIngressNSPodMatchLabels map[string]interface{}

type ValuesNetworkPolicyMetrics struct {
	// Don't require client label for connections for metrics endpoint
	AllowExternal bool `json:"allowExternal,omitempty" yaml:"allowExternal,omitempty" mapstructure:"allowExternal,omitempty"`

	// Labels to match to allow traffic from other namespaces to metrics endpoint
	IngressNSMatchLabels ValuesNetworkPolicyMetricsIngressNSMatchLabels `json:"ingressNSMatchLabels,omitempty" yaml:"ingressNSMatchLabels,omitempty" mapstructure:"ingressNSMatchLabels,omitempty"`

	// Pod labels to match to allow traffic from other namespaces to metrics endpoint
	IngressNSPodMatchLabels ValuesNetworkPolicyMetricsIngressNSPodMatchLabels `json:"ingressNSPodMatchLabels,omitempty" yaml:"ingressNSPodMatchLabels,omitempty" mapstructure:"ingressNSPodMatchLabels,omitempty"`
}

// Labels to match to allow traffic from other namespaces to metrics endpoint
type ValuesNetworkPolicyMetricsIngressNSMatchLabels map[string]interface{}

// Pod labels to match to allow traffic from other namespaces to metrics endpoint
type ValuesNetworkPolicyMetricsIngressNSPodMatchLabels map[string]interface{}

type ValuesPdb struct {
	// Specifies whether a PodDisruptionBudget should be created
	Create bool `json:"create,omitempty" yaml:"create,omitempty" mapstructure:"create,omitempty"`

	// Max number of pods that can be unavailable after the eviction
	MaxUnavailable string `json:"maxUnavailable,omitempty" yaml:"maxUnavailable,omitempty" mapstructure:"maxUnavailable,omitempty"`

	// Min number of pods that must still be available after the eviction
	MinAvailable float64 `json:"minAvailable,omitempty" yaml:"minAvailable,omitempty" mapstructure:"minAvailable,omitempty"`
}

type ValuesPodSecurityPolicy struct {
	// Whether to create a PodSecurityPolicy. WARNING: PodSecurityPolicy is deprecated
	// in Kubernetes v1.21 or later, unavailable in v1.25 or later
	Create bool `json:"create,omitempty" yaml:"create,omitempty" mapstructure:"create,omitempty"`

	// Enable PodSecurityPolicy's RBAC rules
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`
}

type ValuesRbac struct {
	// Specifies whether RBAC resources should be created
	Create bool `json:"create,omitempty" yaml:"create,omitempty" mapstructure:"create,omitempty"`

	// Custom RBAC rules to set
	Rules []interface{} `json:"rules,omitempty" yaml:"rules,omitempty" mapstructure:"rules,omitempty"`
}

type ValuesReplica struct {
	// Affinity for Redis&reg; replicas pods assignment
	Affinity ValuesReplicaAffinity `json:"affinity,omitempty" yaml:"affinity,omitempty" mapstructure:"affinity,omitempty"`

	// Override default container args (useful when using custom images)
	Args []interface{} `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Mount Service Account token in pod
	AutomountServiceAccountToken bool `json:"automountServiceAccountToken,omitempty" yaml:"automountServiceAccountToken,omitempty" mapstructure:"automountServiceAccountToken,omitempty"`

	// Autoscaling corresponds to the JSON schema field "autoscaling".
	Autoscaling *ValuesReplicaAutoscaling `json:"autoscaling,omitempty" yaml:"autoscaling,omitempty" mapstructure:"autoscaling,omitempty"`

	// Override default container command (useful when using custom images)
	Command []interface{} `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Configuration for Redis&reg; replicas nodes
	Configuration string `json:"configuration,omitempty" yaml:"configuration,omitempty" mapstructure:"configuration,omitempty"`

	// ContainerPorts corresponds to the JSON schema field "containerPorts".
	ContainerPorts *ValuesReplicaContainerPorts `json:"containerPorts,omitempty" yaml:"containerPorts,omitempty" mapstructure:"containerPorts,omitempty"`

	// ContainerSecurityContext corresponds to the JSON schema field
	// "containerSecurityContext".
	ContainerSecurityContext *ValuesReplicaContainerSecurityContext `json:"containerSecurityContext,omitempty" yaml:"containerSecurityContext,omitempty" mapstructure:"containerSecurityContext,omitempty"`

	// Custom livenessProbe that overrides the default one
	CustomLivenessProbe ValuesReplicaCustomLivenessProbe `json:"customLivenessProbe,omitempty" yaml:"customLivenessProbe,omitempty" mapstructure:"customLivenessProbe,omitempty"`

	// Custom readinessProbe that overrides the default one
	CustomReadinessProbe ValuesReplicaCustomReadinessProbe `json:"customReadinessProbe,omitempty" yaml:"customReadinessProbe,omitempty" mapstructure:"customReadinessProbe,omitempty"`

	// Custom startupProbe that overrides the default one
	CustomStartupProbe ValuesReplicaCustomStartupProbe `json:"customStartupProbe,omitempty" yaml:"customStartupProbe,omitempty" mapstructure:"customStartupProbe,omitempty"`

	// Array with Redis&reg; commands to disable on replicas nodes
	DisableCommands []string `json:"disableCommands,omitempty" yaml:"disableCommands,omitempty" mapstructure:"disableCommands,omitempty"`

	// DNS Configuration for Redis&reg; replica pods
	DnsConfig ValuesReplicaDnsConfig `json:"dnsConfig,omitempty" yaml:"dnsConfig,omitempty" mapstructure:"dnsConfig,omitempty"`

	// DNS Policy for Redis&reg; replica pods
	DnsPolicy string `json:"dnsPolicy,omitempty" yaml:"dnsPolicy,omitempty" mapstructure:"dnsPolicy,omitempty"`

	// Whether information about services should be injected into pod's environment
	// variable
	EnableServiceLinks bool `json:"enableServiceLinks,omitempty" yaml:"enableServiceLinks,omitempty" mapstructure:"enableServiceLinks,omitempty"`

	// ExternalMaster corresponds to the JSON schema field "externalMaster".
	ExternalMaster *ValuesReplicaExternalMaster `json:"externalMaster,omitempty" yaml:"externalMaster,omitempty" mapstructure:"externalMaster,omitempty"`

	// Array with extra environment variables to add to Redis&reg; replicas nodes
	ExtraEnvVars []interface{} `json:"extraEnvVars,omitempty" yaml:"extraEnvVars,omitempty" mapstructure:"extraEnvVars,omitempty"`

	// Name of existing ConfigMap containing extra env vars for Redis&reg; replicas
	// nodes
	ExtraEnvVarsCM string `json:"extraEnvVarsCM,omitempty" yaml:"extraEnvVarsCM,omitempty" mapstructure:"extraEnvVarsCM,omitempty"`

	// Name of existing Secret containing extra env vars for Redis&reg; replicas nodes
	ExtraEnvVarsSecret string `json:"extraEnvVarsSecret,omitempty" yaml:"extraEnvVarsSecret,omitempty" mapstructure:"extraEnvVarsSecret,omitempty"`

	// Array with additional command line flags for Redis&reg; replicas
	ExtraFlags []interface{} `json:"extraFlags,omitempty" yaml:"extraFlags,omitempty" mapstructure:"extraFlags,omitempty"`

	// Optionally specify extra list of additional volumeMounts for the Redis&reg;
	// replicas container(s)
	ExtraVolumeMounts []interface{} `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty" mapstructure:"extraVolumeMounts,omitempty"`

	// Optionally specify extra list of additional volumes for the Redis&reg; replicas
	// pod(s)
	ExtraVolumes []interface{} `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty" mapstructure:"extraVolumes,omitempty"`

	// Redis&reg; replicas pods host aliases
	HostAliases []interface{} `json:"hostAliases,omitempty" yaml:"hostAliases,omitempty" mapstructure:"hostAliases,omitempty"`

	// Add additional init containers to the Redis&reg; replicas pod(s)
	InitContainers []interface{} `json:"initContainers,omitempty" yaml:"initContainers,omitempty" mapstructure:"initContainers,omitempty"`

	// Use either DaemonSet or StatefulSet (default)
	Kind string `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// for the Redis&reg; replica container(s) to automate configuration before or
	// after startup
	LifecycleHooks ValuesReplicaLifecycleHooks `json:"lifecycleHooks,omitempty" yaml:"lifecycleHooks,omitempty" mapstructure:"lifecycleHooks,omitempty"`

	// LivenessProbe corresponds to the JSON schema field "livenessProbe".
	LivenessProbe *ValuesReplicaLivenessProbe `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty" mapstructure:"livenessProbe,omitempty"`

	// How many seconds a pod needs to be ready before killing the next, during update
	MinReadySeconds float64 `json:"minReadySeconds,omitempty" yaml:"minReadySeconds,omitempty" mapstructure:"minReadySeconds,omitempty"`

	// NodeAffinityPreset corresponds to the JSON schema field "nodeAffinityPreset".
	NodeAffinityPreset *ValuesReplicaNodeAffinityPreset `json:"nodeAffinityPreset,omitempty" yaml:"nodeAffinityPreset,omitempty" mapstructure:"nodeAffinityPreset,omitempty"`

	// Node labels for Redis&reg; replicas pods assignment
	NodeSelector ValuesReplicaNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty" mapstructure:"nodeSelector,omitempty"`

	// Persistence corresponds to the JSON schema field "persistence".
	Persistence *ValuesReplicaPersistence `json:"persistence,omitempty" yaml:"persistence,omitempty" mapstructure:"persistence,omitempty"`

	// PersistentVolumeClaimRetentionPolicy corresponds to the JSON schema field
	// "persistentVolumeClaimRetentionPolicy".
	PersistentVolumeClaimRetentionPolicy *ValuesReplicaPersistentVolumeClaimRetentionPolicy `json:"persistentVolumeClaimRetentionPolicy,omitempty" yaml:"persistentVolumeClaimRetentionPolicy,omitempty" mapstructure:"persistentVolumeClaimRetentionPolicy,omitempty"`

	// Pod affinity preset. Ignored if `replica.affinity` is set. Allowed values:
	// `soft` or `hard`
	PodAffinityPreset string `json:"podAffinityPreset,omitempty" yaml:"podAffinityPreset,omitempty" mapstructure:"podAffinityPreset,omitempty"`

	// Annotations for Redis&reg; replicas pods
	PodAnnotations ValuesReplicaPodAnnotations `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty" mapstructure:"podAnnotations,omitempty"`

	// Pod anti-affinity preset. Ignored if `replica.affinity` is set. Allowed values:
	// `soft` or `hard`
	PodAntiAffinityPreset string `json:"podAntiAffinityPreset,omitempty" yaml:"podAntiAffinityPreset,omitempty" mapstructure:"podAntiAffinityPreset,omitempty"`

	// Extra labels for Redis&reg; replicas pods
	PodLabels ValuesReplicaPodLabels `json:"podLabels,omitempty" yaml:"podLabels,omitempty" mapstructure:"podLabels,omitempty"`

	// podManagementPolicy to manage scaling operation of %%MAIN_CONTAINER_NAME%% pods
	PodManagementPolicy string `json:"podManagementPolicy,omitempty" yaml:"podManagementPolicy,omitempty" mapstructure:"podManagementPolicy,omitempty"`

	// PodSecurityContext corresponds to the JSON schema field "podSecurityContext".
	PodSecurityContext *ValuesReplicaPodSecurityContext `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty" mapstructure:"podSecurityContext,omitempty"`

	// Additional commands to run prior to starting Redis&reg; replicas
	PreExecCmds []interface{} `json:"preExecCmds,omitempty" yaml:"preExecCmds,omitempty" mapstructure:"preExecCmds,omitempty"`

	// Redis&reg; replicas pods' priorityClassName
	PriorityClassName string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty" mapstructure:"priorityClassName,omitempty"`

	// ReadinessProbe corresponds to the JSON schema field "readinessProbe".
	ReadinessProbe *ValuesReplicaReadinessProbe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty" mapstructure:"readinessProbe,omitempty"`

	// Number of Redis&reg; replicas to deploy
	ReplicaCount float64 `json:"replicaCount,omitempty" yaml:"replicaCount,omitempty" mapstructure:"replicaCount,omitempty"`

	// Set container requests and limits for different resources like CPU or memory
	// (essential for production workloads)
	Resources ValuesReplicaResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Set container resources according to one common preset (allowed values: none,
	// nano, small, medium, large, xlarge, 2xlarge). This is ignored if
	// replica.resources is set (replica.resources is recommended for production).
	ResourcesPreset string `json:"resourcesPreset,omitempty" yaml:"resourcesPreset,omitempty" mapstructure:"resourcesPreset,omitempty"`

	// Alternate scheduler for Redis&reg; replicas pods
	SchedulerName string `json:"schedulerName,omitempty" yaml:"schedulerName,omitempty" mapstructure:"schedulerName,omitempty"`

	// Service corresponds to the JSON schema field "service".
	Service *ValuesReplicaService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`

	// ServiceAccount corresponds to the JSON schema field "serviceAccount".
	ServiceAccount *ValuesReplicaServiceAccount `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty" mapstructure:"serviceAccount,omitempty"`

	// Share a single process namespace between all of the containers in Redis&reg;
	// replicas pods
	ShareProcessNamespace bool `json:"shareProcessNamespace,omitempty" yaml:"shareProcessNamespace,omitempty" mapstructure:"shareProcessNamespace,omitempty"`

	// Add additional sidecar containers to the Redis&reg; replicas pod(s)
	Sidecars []interface{} `json:"sidecars,omitempty" yaml:"sidecars,omitempty" mapstructure:"sidecars,omitempty"`

	// StartupProbe corresponds to the JSON schema field "startupProbe".
	StartupProbe *ValuesReplicaStartupProbe `json:"startupProbe,omitempty" yaml:"startupProbe,omitempty" mapstructure:"startupProbe,omitempty"`

	// Integer setting the termination grace period for the redis-replicas pods
	TerminationGracePeriodSeconds float64 `json:"terminationGracePeriodSeconds,omitempty" yaml:"terminationGracePeriodSeconds,omitempty" mapstructure:"terminationGracePeriodSeconds,omitempty"`

	// Tolerations for Redis&reg; replicas pods assignment
	Tolerations []interface{} `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`

	// Spread Constraints for Redis&reg; replicas pod assignment
	TopologySpreadConstraints []interface{} `json:"topologySpreadConstraints,omitempty" yaml:"topologySpreadConstraints,omitempty" mapstructure:"topologySpreadConstraints,omitempty"`

	// UpdateStrategy corresponds to the JSON schema field "updateStrategy".
	UpdateStrategy *ValuesReplicaUpdateStrategy `json:"updateStrategy,omitempty" yaml:"updateStrategy,omitempty" mapstructure:"updateStrategy,omitempty"`
}

// Affinity for Redis&reg; replicas pods assignment
type ValuesReplicaAffinity map[string]interface{}

type ValuesReplicaAutoscaling struct {
	// Enable replica autoscaling settings
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Maximum replicas for the pod autoscaling
	MaxReplicas float64 `json:"maxReplicas,omitempty" yaml:"maxReplicas,omitempty" mapstructure:"maxReplicas,omitempty"`

	// Minimum replicas for the pod autoscaling
	MinReplicas float64 `json:"minReplicas,omitempty" yaml:"minReplicas,omitempty" mapstructure:"minReplicas,omitempty"`

	// Percentage of CPU to consider when autoscaling
	TargetCPU string `json:"targetCPU,omitempty" yaml:"targetCPU,omitempty" mapstructure:"targetCPU,omitempty"`

	// Percentage of Memory to consider when autoscaling
	TargetMemory string `json:"targetMemory,omitempty" yaml:"targetMemory,omitempty" mapstructure:"targetMemory,omitempty"`
}

type ValuesReplicaContainerPorts struct {
	// Container port to open on Redis&reg; replicas nodes
	Redis float64 `json:"redis,omitempty" yaml:"redis,omitempty" mapstructure:"redis,omitempty"`
}

type ValuesReplicaContainerSecurityContext struct {
	// Set Redis&reg; replicas pod's Security Context allowPrivilegeEscalation
	AllowPrivilegeEscalation bool `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty" mapstructure:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *ValuesReplicaContainerSecurityContextCapabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty" mapstructure:"capabilities,omitempty"`

	// Enabled Redis&reg; replicas containers' Security Context
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Set container's Security Context read-only root filesystem
	ReadOnlyRootFilesystem bool `json:"readOnlyRootFilesystem,omitempty" yaml:"readOnlyRootFilesystem,omitempty" mapstructure:"readOnlyRootFilesystem,omitempty"`

	// Set Redis&reg; replicas containers' Security Context runAsGroup
	RunAsGroup float64 `json:"runAsGroup,omitempty" yaml:"runAsGroup,omitempty" mapstructure:"runAsGroup,omitempty"`

	// Set Redis&reg; replicas containers' Security Context runAsNonRoot
	RunAsNonRoot bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty" mapstructure:"runAsNonRoot,omitempty"`

	// Set Redis&reg; replicas containers' Security Context runAsUser
	RunAsUser float64 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *ValuesReplicaContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty" mapstructure:"seccompProfile,omitempty"`
}

type ValuesReplicaContainerSecurityContextCapabilities struct {
	// Set Redis&reg; replicas containers' Security Context capabilities to drop
	Drop []string `json:"drop,omitempty" yaml:"drop,omitempty" mapstructure:"drop,omitempty"`
}

type ValuesReplicaContainerSecurityContextSeccompProfile struct {
	// Set Redis&reg; replicas containers' Security Context seccompProfile
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// Custom livenessProbe that overrides the default one
type ValuesReplicaCustomLivenessProbe map[string]interface{}

// Custom readinessProbe that overrides the default one
type ValuesReplicaCustomReadinessProbe map[string]interface{}

// Custom startupProbe that overrides the default one
type ValuesReplicaCustomStartupProbe map[string]interface{}

// DNS Configuration for Redis&reg; replica pods
type ValuesReplicaDnsConfig map[string]interface{}

type ValuesReplicaExternalMaster struct {
	// Use external master for bootstrapping
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// External master host to bootstrap from
	Host string `json:"host,omitempty" yaml:"host,omitempty" mapstructure:"host,omitempty"`

	// Port for Redis service external master host
	Port float64 `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`
}

// for the Redis&reg; replica container(s) to automate configuration before or
// after startup
type ValuesReplicaLifecycleHooks map[string]interface{}

type ValuesReplicaLivenessProbe struct {
	// Enable livenessProbe on Redis&reg; replicas nodes
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for livenessProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for livenessProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for livenessProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for livenessProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for livenessProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

type ValuesReplicaNodeAffinityPreset struct {
	// Node label key to match. Ignored if `replica.affinity` is set
	Key string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Node affinity preset type. Ignored if `replica.affinity` is set. Allowed
	// values: `soft` or `hard`
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// Node label values to match. Ignored if `replica.affinity` is set
	Values []interface{} `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// Node labels for Redis&reg; replicas pods assignment
type ValuesReplicaNodeSelector map[string]interface{}

type ValuesReplicaPersistence struct {
	// Persistent Volume access modes
	AccessModes []string `json:"accessModes,omitempty" yaml:"accessModes,omitempty" mapstructure:"accessModes,omitempty"`

	// Additional custom annotations for the PVC
	Annotations ValuesReplicaPersistenceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Custom PVC data source
	DataSource ValuesReplicaPersistenceDataSource `json:"dataSource,omitempty" yaml:"dataSource,omitempty" mapstructure:"dataSource,omitempty"`

	// Enable persistence on Redis&reg; replicas nodes using Persistent Volume Claims
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Use a existing PVC which must be created manually before bound
	ExistingClaim string `json:"existingClaim,omitempty" yaml:"existingClaim,omitempty" mapstructure:"existingClaim,omitempty"`

	// Additional custom labels for the PVC
	Labels ValuesReplicaPersistenceLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Provide a medium for `emptyDir` volumes.
	Medium string `json:"medium,omitempty" yaml:"medium,omitempty" mapstructure:"medium,omitempty"`

	// The path the volume will be mounted at on Redis&reg; replicas containers
	Path string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// Additional labels to match for the PVC
	Selector ValuesReplicaPersistenceSelector `json:"selector,omitempty" yaml:"selector,omitempty" mapstructure:"selector,omitempty"`

	// Persistent Volume size
	Size string `json:"size,omitempty" yaml:"size,omitempty" mapstructure:"size,omitempty"`

	// Set this to enable a size limit for `emptyDir` volumes.
	SizeLimit string `json:"sizeLimit,omitempty" yaml:"sizeLimit,omitempty" mapstructure:"sizeLimit,omitempty"`

	// Persistent Volume storage class
	StorageClass string `json:"storageClass,omitempty" yaml:"storageClass,omitempty" mapstructure:"storageClass,omitempty"`

	// The subdirectory of the volume to mount on Redis&reg; replicas containers
	SubPath string `json:"subPath,omitempty" yaml:"subPath,omitempty" mapstructure:"subPath,omitempty"`

	// Used to construct the subPath subdirectory of the volume to mount on Redis&reg;
	// replicas containers
	SubPathExpr string `json:"subPathExpr,omitempty" yaml:"subPathExpr,omitempty" mapstructure:"subPathExpr,omitempty"`
}

// Additional custom annotations for the PVC
type ValuesReplicaPersistenceAnnotations map[string]interface{}

// Custom PVC data source
type ValuesReplicaPersistenceDataSource map[string]interface{}

// Additional custom labels for the PVC
type ValuesReplicaPersistenceLabels map[string]interface{}

// Additional labels to match for the PVC
type ValuesReplicaPersistenceSelector map[string]interface{}

type ValuesReplicaPersistentVolumeClaimRetentionPolicy struct {
	// Controls if and how PVCs are deleted during the lifecycle of a StatefulSet
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Volume retention behavior that applies when the StatefulSet is deleted
	WhenDeleted string `json:"whenDeleted,omitempty" yaml:"whenDeleted,omitempty" mapstructure:"whenDeleted,omitempty"`

	// Volume retention behavior when the replica count of the StatefulSet is reduced
	WhenScaled string `json:"whenScaled,omitempty" yaml:"whenScaled,omitempty" mapstructure:"whenScaled,omitempty"`
}

// Annotations for Redis&reg; replicas pods
type ValuesReplicaPodAnnotations map[string]interface{}

// Extra labels for Redis&reg; replicas pods
type ValuesReplicaPodLabels map[string]interface{}

type ValuesReplicaPodSecurityContext struct {
	// Enabled Redis&reg; replicas pods' Security Context
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Set Redis&reg; replicas pod's Security Context fsGroup
	FsGroup float64 `json:"fsGroup,omitempty" yaml:"fsGroup,omitempty" mapstructure:"fsGroup,omitempty"`

	// Set filesystem group change policy
	FsGroupChangePolicy string `json:"fsGroupChangePolicy,omitempty" yaml:"fsGroupChangePolicy,omitempty" mapstructure:"fsGroupChangePolicy,omitempty"`

	// Set filesystem extra groups
	SupplementalGroups []interface{} `json:"supplementalGroups,omitempty" yaml:"supplementalGroups,omitempty" mapstructure:"supplementalGroups,omitempty"`

	// Set kernel settings using the sysctl interface
	Sysctls []interface{} `json:"sysctls,omitempty" yaml:"sysctls,omitempty" mapstructure:"sysctls,omitempty"`
}

type ValuesReplicaReadinessProbe struct {
	// Enable readinessProbe on Redis&reg; replicas nodes
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for readinessProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for readinessProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for readinessProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for readinessProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for readinessProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

// Set container requests and limits for different resources like CPU or memory
// (essential for production workloads)
type ValuesReplicaResources map[string]interface{}

type ValuesReplicaService struct {
	// Additional custom annotations for Redis&reg; replicas service
	Annotations ValuesReplicaServiceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Redis&reg; replicas service Cluster IP
	ClusterIP string `json:"clusterIP,omitempty" yaml:"clusterIP,omitempty" mapstructure:"clusterIP,omitempty"`

	// Redis&reg; replicas service external traffic policy
	ExternalTrafficPolicy string `json:"externalTrafficPolicy,omitempty" yaml:"externalTrafficPolicy,omitempty" mapstructure:"externalTrafficPolicy,omitempty"`

	// Extra ports to expose (normally used with the `sidecar` value)
	ExtraPorts []interface{} `json:"extraPorts,omitempty" yaml:"extraPorts,omitempty" mapstructure:"extraPorts,omitempty"`

	// Redis&reg; replicas service internal traffic policy (requires Kubernetes v1.22
	// or greater to be usable)
	InternalTrafficPolicy string `json:"internalTrafficPolicy,omitempty" yaml:"internalTrafficPolicy,omitempty" mapstructure:"internalTrafficPolicy,omitempty"`

	// replicas service Load Balancer class if service type is `LoadBalancer`
	// (optional, cloud specific)
	LoadBalancerClass string `json:"loadBalancerClass,omitempty" yaml:"loadBalancerClass,omitempty" mapstructure:"loadBalancerClass,omitempty"`

	// Redis&reg; replicas service Load Balancer IP
	LoadBalancerIP string `json:"loadBalancerIP,omitempty" yaml:"loadBalancerIP,omitempty" mapstructure:"loadBalancerIP,omitempty"`

	// Redis&reg; replicas service Load Balancer sources
	LoadBalancerSourceRanges []interface{} `json:"loadBalancerSourceRanges,omitempty" yaml:"loadBalancerSourceRanges,omitempty" mapstructure:"loadBalancerSourceRanges,omitempty"`

	// NodePorts corresponds to the JSON schema field "nodePorts".
	NodePorts *ValuesReplicaServiceNodePorts `json:"nodePorts,omitempty" yaml:"nodePorts,omitempty" mapstructure:"nodePorts,omitempty"`

	// Ports corresponds to the JSON schema field "ports".
	Ports *ValuesReplicaServicePorts `json:"ports,omitempty" yaml:"ports,omitempty" mapstructure:"ports,omitempty"`

	// Session Affinity for Kubernetes service, can be "None" or "ClientIP"
	SessionAffinity string `json:"sessionAffinity,omitempty" yaml:"sessionAffinity,omitempty" mapstructure:"sessionAffinity,omitempty"`

	// Additional settings for the sessionAffinity
	SessionAffinityConfig ValuesReplicaServiceSessionAffinityConfig `json:"sessionAffinityConfig,omitempty" yaml:"sessionAffinityConfig,omitempty" mapstructure:"sessionAffinityConfig,omitempty"`

	// Redis&reg; replicas service type
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type ValuesReplicaServiceAccount struct {
	// Additional custom annotations for the ServiceAccount
	Annotations ValuesReplicaServiceAccountAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Whether to auto mount the service account token
	AutomountServiceAccountToken bool `json:"automountServiceAccountToken,omitempty" yaml:"automountServiceAccountToken,omitempty" mapstructure:"automountServiceAccountToken,omitempty"`

	// Specifies whether a ServiceAccount should be created
	Create bool `json:"create,omitempty" yaml:"create,omitempty" mapstructure:"create,omitempty"`

	// The name of the ServiceAccount to use.
	Name string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// Additional custom annotations for the ServiceAccount
type ValuesReplicaServiceAccountAnnotations map[string]interface{}

// Additional custom annotations for Redis&reg; replicas service
type ValuesReplicaServiceAnnotations map[string]interface{}

type ValuesReplicaServiceNodePorts struct {
	// Node port for Redis&reg; replicas
	Redis string `json:"redis,omitempty" yaml:"redis,omitempty" mapstructure:"redis,omitempty"`
}

type ValuesReplicaServicePorts struct {
	// Redis&reg; replicas service port
	Redis float64 `json:"redis,omitempty" yaml:"redis,omitempty" mapstructure:"redis,omitempty"`
}

// Additional settings for the sessionAffinity
type ValuesReplicaServiceSessionAffinityConfig map[string]interface{}

type ValuesReplicaStartupProbe struct {
	// Enable startupProbe on Redis&reg; replicas nodes
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for startupProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for startupProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for startupProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for startupProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for startupProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

type ValuesReplicaUpdateStrategy struct {
	// Redis&reg; replicas statefulset strategy type
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// Annotations to add to secret
type ValuesSecretAnnotations map[string]interface{}

type ValuesSentinel struct {
	// Additional custom annotations for Redis&reg; Sentinel resource
	Annotations ValuesSentinelAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Override default container args (useful when using custom images)
	Args []interface{} `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Automate cluster recovery in cases where the last replica is not considered a
	// good replica and Sentinel won't automatically failover to it.
	AutomateClusterRecovery bool `json:"automateClusterRecovery,omitempty" yaml:"automateClusterRecovery,omitempty" mapstructure:"automateClusterRecovery,omitempty"`

	// Override default container command (useful when using custom images)
	Command []interface{} `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Configuration for Redis&reg; Sentinel nodes
	Configuration string `json:"configuration,omitempty" yaml:"configuration,omitempty" mapstructure:"configuration,omitempty"`

	// ContainerPorts corresponds to the JSON schema field "containerPorts".
	ContainerPorts *ValuesSentinelContainerPorts `json:"containerPorts,omitempty" yaml:"containerPorts,omitempty" mapstructure:"containerPorts,omitempty"`

	// ContainerSecurityContext corresponds to the JSON schema field
	// "containerSecurityContext".
	ContainerSecurityContext *ValuesSentinelContainerSecurityContext `json:"containerSecurityContext,omitempty" yaml:"containerSecurityContext,omitempty" mapstructure:"containerSecurityContext,omitempty"`

	// Custom livenessProbe that overrides the default one
	CustomLivenessProbe ValuesSentinelCustomLivenessProbe `json:"customLivenessProbe,omitempty" yaml:"customLivenessProbe,omitempty" mapstructure:"customLivenessProbe,omitempty"`

	// Custom readinessProbe that overrides the default one
	CustomReadinessProbe ValuesSentinelCustomReadinessProbe `json:"customReadinessProbe,omitempty" yaml:"customReadinessProbe,omitempty" mapstructure:"customReadinessProbe,omitempty"`

	// Custom startupProbe that overrides the default one
	CustomStartupProbe ValuesSentinelCustomStartupProbe `json:"customStartupProbe,omitempty" yaml:"customStartupProbe,omitempty" mapstructure:"customStartupProbe,omitempty"`

	// Timeout for detecting a Redis&reg; node is down
	DownAfterMilliseconds float64 `json:"downAfterMilliseconds,omitempty" yaml:"downAfterMilliseconds,omitempty" mapstructure:"downAfterMilliseconds,omitempty"`

	// Whether information about services should be injected into pod's environment
	// variable
	EnableServiceLinks bool `json:"enableServiceLinks,omitempty" yaml:"enableServiceLinks,omitempty" mapstructure:"enableServiceLinks,omitempty"`

	// Use Redis&reg; Sentinel on Redis&reg; pods.
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// ExternalMaster corresponds to the JSON schema field "externalMaster".
	ExternalMaster *ValuesSentinelExternalMaster `json:"externalMaster,omitempty" yaml:"externalMaster,omitempty" mapstructure:"externalMaster,omitempty"`

	// Array with extra environment variables to add to Redis&reg; Sentinel nodes
	ExtraEnvVars []interface{} `json:"extraEnvVars,omitempty" yaml:"extraEnvVars,omitempty" mapstructure:"extraEnvVars,omitempty"`

	// Name of existing ConfigMap containing extra env vars for Redis&reg; Sentinel
	// nodes
	ExtraEnvVarsCM string `json:"extraEnvVarsCM,omitempty" yaml:"extraEnvVarsCM,omitempty" mapstructure:"extraEnvVarsCM,omitempty"`

	// Name of existing Secret containing extra env vars for Redis&reg; Sentinel nodes
	ExtraEnvVarsSecret string `json:"extraEnvVarsSecret,omitempty" yaml:"extraEnvVarsSecret,omitempty" mapstructure:"extraEnvVarsSecret,omitempty"`

	// Optionally specify extra list of additional volumeMounts for the Redis&reg;
	// Sentinel container(s)
	ExtraVolumeMounts []interface{} `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty" mapstructure:"extraVolumeMounts,omitempty"`

	// Optionally specify extra list of additional volumes for the Redis&reg; Sentinel
	ExtraVolumes []interface{} `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty" mapstructure:"extraVolumes,omitempty"`

	// Timeout for performing a election failover
	FailoverTimeout float64 `json:"failoverTimeout,omitempty" yaml:"failoverTimeout,omitempty" mapstructure:"failoverTimeout,omitempty"`

	// Amount of time to allow before get_sentinel_master_info() times out.
	GetMasterTimeout float64 `json:"getMasterTimeout,omitempty" yaml:"getMasterTimeout,omitempty" mapstructure:"getMasterTimeout,omitempty"`

	// Image corresponds to the JSON schema field "image".
	Image *ValuesSentinelImage `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// for the Redis&reg; sentinel container(s) to automate configuration before or
	// after startup
	LifecycleHooks ValuesSentinelLifecycleHooks `json:"lifecycleHooks,omitempty" yaml:"lifecycleHooks,omitempty" mapstructure:"lifecycleHooks,omitempty"`

	// LivenessProbe corresponds to the JSON schema field "livenessProbe".
	LivenessProbe *ValuesSentinelLivenessProbe `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty" mapstructure:"livenessProbe,omitempty"`

	// Master set name
	MasterSet string `json:"masterSet,omitempty" yaml:"masterSet,omitempty" mapstructure:"masterSet,omitempty"`

	// Number of replicas that can be reconfigured in parallel to use the new master
	// after a failover
	ParallelSyncs float64 `json:"parallelSyncs,omitempty" yaml:"parallelSyncs,omitempty" mapstructure:"parallelSyncs,omitempty"`

	// Persistence corresponds to the JSON schema field "persistence".
	Persistence *ValuesSentinelPersistence `json:"persistence,omitempty" yaml:"persistence,omitempty" mapstructure:"persistence,omitempty"`

	// PersistentVolumeClaimRetentionPolicy corresponds to the JSON schema field
	// "persistentVolumeClaimRetentionPolicy".
	PersistentVolumeClaimRetentionPolicy *ValuesSentinelPersistentVolumeClaimRetentionPolicy `json:"persistentVolumeClaimRetentionPolicy,omitempty" yaml:"persistentVolumeClaimRetentionPolicy,omitempty" mapstructure:"persistentVolumeClaimRetentionPolicy,omitempty"`

	// Additional commands to run prior to starting Redis&reg; Sentinel
	PreExecCmds []interface{} `json:"preExecCmds,omitempty" yaml:"preExecCmds,omitempty" mapstructure:"preExecCmds,omitempty"`

	// Sentinel Quorum
	Quorum float64 `json:"quorum,omitempty" yaml:"quorum,omitempty" mapstructure:"quorum,omitempty"`

	// ReadinessProbe corresponds to the JSON schema field "readinessProbe".
	ReadinessProbe *ValuesSentinelReadinessProbe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty" mapstructure:"readinessProbe,omitempty"`

	// Whether the Redis&reg; master container waits for the failover at shutdown (in
	// addition to the Redis&reg; Sentinel container).
	RedisShutdownWaitFailover bool `json:"redisShutdownWaitFailover,omitempty" yaml:"redisShutdownWaitFailover,omitempty" mapstructure:"redisShutdownWaitFailover,omitempty"`

	// Set container requests and limits for different resources like CPU or memory
	// (essential for production workloads)
	Resources ValuesSentinelResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Set container resources according to one common preset (allowed values: none,
	// nano, small, medium, large, xlarge, 2xlarge). This is ignored if
	// sentinel.resources is set (sentinel.resources is recommended for production).
	ResourcesPreset string `json:"resourcesPreset,omitempty" yaml:"resourcesPreset,omitempty" mapstructure:"resourcesPreset,omitempty"`

	// Service corresponds to the JSON schema field "service".
	Service *ValuesSentinelService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`

	// StartupProbe corresponds to the JSON schema field "startupProbe".
	StartupProbe *ValuesSentinelStartupProbe `json:"startupProbe,omitempty" yaml:"startupProbe,omitempty" mapstructure:"startupProbe,omitempty"`

	// Integer setting the termination grace period for the redis-node pods
	TerminationGracePeriodSeconds float64 `json:"terminationGracePeriodSeconds,omitempty" yaml:"terminationGracePeriodSeconds,omitempty" mapstructure:"terminationGracePeriodSeconds,omitempty"`
}

// Additional custom annotations for Redis&reg; Sentinel resource
type ValuesSentinelAnnotations map[string]interface{}

type ValuesSentinelContainerPorts struct {
	// Container port to open on Redis&reg; Sentinel nodes
	Sentinel float64 `json:"sentinel,omitempty" yaml:"sentinel,omitempty" mapstructure:"sentinel,omitempty"`
}

type ValuesSentinelContainerSecurityContext struct {
	// Set Redis&reg; Sentinel containers' Security Context allowPrivilegeEscalation
	AllowPrivilegeEscalation bool `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty" mapstructure:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *ValuesSentinelContainerSecurityContextCapabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty" mapstructure:"capabilities,omitempty"`

	// Enabled Redis&reg; Sentinel containers' Security Context
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Set container's Security Context read-only root filesystem
	ReadOnlyRootFilesystem bool `json:"readOnlyRootFilesystem,omitempty" yaml:"readOnlyRootFilesystem,omitempty" mapstructure:"readOnlyRootFilesystem,omitempty"`

	// Set Redis&reg; Sentinel containers' Security Context runAsGroup
	RunAsGroup float64 `json:"runAsGroup,omitempty" yaml:"runAsGroup,omitempty" mapstructure:"runAsGroup,omitempty"`

	// Set Redis&reg; Sentinel containers' Security Context runAsNonRoot
	RunAsNonRoot bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty" mapstructure:"runAsNonRoot,omitempty"`

	// Set Redis&reg; Sentinel containers' Security Context runAsUser
	RunAsUser float64 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *ValuesSentinelContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty" mapstructure:"seccompProfile,omitempty"`
}

type ValuesSentinelContainerSecurityContextCapabilities struct {
	// Set Redis&reg; Sentinel containers' Security Context capabilities to drop
	Drop []string `json:"drop,omitempty" yaml:"drop,omitempty" mapstructure:"drop,omitempty"`
}

type ValuesSentinelContainerSecurityContextSeccompProfile struct {
	// Set Redis&reg; Sentinel containers' Security Context seccompProfile
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// Custom livenessProbe that overrides the default one
type ValuesSentinelCustomLivenessProbe map[string]interface{}

// Custom readinessProbe that overrides the default one
type ValuesSentinelCustomReadinessProbe map[string]interface{}

// Custom startupProbe that overrides the default one
type ValuesSentinelCustomStartupProbe map[string]interface{}

type ValuesSentinelExternalMaster struct {
	// Use external master for bootstrapping
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// External master host to bootstrap from
	Host string `json:"host,omitempty" yaml:"host,omitempty" mapstructure:"host,omitempty"`

	// Port for Redis service external master host
	Port float64 `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`
}

type ValuesSentinelImage struct {
	// Enable image debug mode
	Debug bool `json:"debug,omitempty" yaml:"debug,omitempty" mapstructure:"debug,omitempty"`

	// Redis&reg; Sentinel image digest in the way sha256:aa.... Please note this
	// parameter, if set, will override the tag
	Digest string `json:"digest,omitempty" yaml:"digest,omitempty" mapstructure:"digest,omitempty"`

	// Redis&reg; Sentinel image pull policy
	PullPolicy string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty" mapstructure:"pullPolicy,omitempty"`

	// Redis&reg; Sentinel image pull secrets
	PullSecrets []interface{} `json:"pullSecrets,omitempty" yaml:"pullSecrets,omitempty" mapstructure:"pullSecrets,omitempty"`

	// Redis&reg; Sentinel image registry
	Registry string `json:"registry,omitempty" yaml:"registry,omitempty" mapstructure:"registry,omitempty"`

	// Redis&reg; Sentinel image repository
	Repository string `json:"repository,omitempty" yaml:"repository,omitempty" mapstructure:"repository,omitempty"`
}

// for the Redis&reg; sentinel container(s) to automate configuration before or
// after startup
type ValuesSentinelLifecycleHooks map[string]interface{}

type ValuesSentinelLivenessProbe struct {
	// Enable livenessProbe on Redis&reg; Sentinel nodes
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for livenessProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for livenessProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for livenessProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for livenessProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for livenessProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

type ValuesSentinelPersistence struct {
	// Persistent Volume access modes
	AccessModes []string `json:"accessModes,omitempty" yaml:"accessModes,omitempty" mapstructure:"accessModes,omitempty"`

	// Additional custom annotations for the PVC
	Annotations ValuesSentinelPersistenceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Custom PVC data source
	DataSource ValuesSentinelPersistenceDataSource `json:"dataSource,omitempty" yaml:"dataSource,omitempty" mapstructure:"dataSource,omitempty"`

	// Enable persistence on Redis&reg; sentinel nodes using Persistent Volume Claims
	// (Experimental)
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Additional custom labels for the PVC
	Labels ValuesSentinelPersistenceLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Provide a medium for `emptyDir` volumes.
	Medium string `json:"medium,omitempty" yaml:"medium,omitempty" mapstructure:"medium,omitempty"`

	// Additional labels to match for the PVC
	Selector ValuesSentinelPersistenceSelector `json:"selector,omitempty" yaml:"selector,omitempty" mapstructure:"selector,omitempty"`

	// Persistent Volume size
	Size string `json:"size,omitempty" yaml:"size,omitempty" mapstructure:"size,omitempty"`

	// Set this to enable a size limit for `emptyDir` volumes.
	SizeLimit string `json:"sizeLimit,omitempty" yaml:"sizeLimit,omitempty" mapstructure:"sizeLimit,omitempty"`

	// Persistent Volume storage class
	StorageClass string `json:"storageClass,omitempty" yaml:"storageClass,omitempty" mapstructure:"storageClass,omitempty"`
}

// Additional custom annotations for the PVC
type ValuesSentinelPersistenceAnnotations map[string]interface{}

// Custom PVC data source
type ValuesSentinelPersistenceDataSource map[string]interface{}

// Additional custom labels for the PVC
type ValuesSentinelPersistenceLabels map[string]interface{}

// Additional labels to match for the PVC
type ValuesSentinelPersistenceSelector map[string]interface{}

type ValuesSentinelPersistentVolumeClaimRetentionPolicy struct {
	// Controls if and how PVCs are deleted during the lifecycle of a StatefulSet
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Volume retention behavior that applies when the StatefulSet is deleted
	WhenDeleted string `json:"whenDeleted,omitempty" yaml:"whenDeleted,omitempty" mapstructure:"whenDeleted,omitempty"`

	// Volume retention behavior when the replica count of the StatefulSet is reduced
	WhenScaled string `json:"whenScaled,omitempty" yaml:"whenScaled,omitempty" mapstructure:"whenScaled,omitempty"`
}

type ValuesSentinelReadinessProbe struct {
	// Enable readinessProbe on Redis&reg; Sentinel nodes
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for readinessProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for readinessProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for readinessProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for readinessProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for readinessProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

// Set container requests and limits for different resources like CPU or memory
// (essential for production workloads)
type ValuesSentinelResources map[string]interface{}

type ValuesSentinelService struct {
	// Additional custom annotations for Redis&reg; Sentinel service
	Annotations ValuesSentinelServiceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Redis&reg; Sentinel service Cluster IP
	ClusterIP string `json:"clusterIP,omitempty" yaml:"clusterIP,omitempty" mapstructure:"clusterIP,omitempty"`

	// Redis&reg; Sentinel service external traffic policy
	ExternalTrafficPolicy string `json:"externalTrafficPolicy,omitempty" yaml:"externalTrafficPolicy,omitempty" mapstructure:"externalTrafficPolicy,omitempty"`

	// Extra ports to expose (normally used with the `sidecar` value)
	ExtraPorts []interface{} `json:"extraPorts,omitempty" yaml:"extraPorts,omitempty" mapstructure:"extraPorts,omitempty"`

	// Headless corresponds to the JSON schema field "headless".
	Headless *ValuesSentinelServiceHeadless `json:"headless,omitempty" yaml:"headless,omitempty" mapstructure:"headless,omitempty"`

	// sentinel service Load Balancer class if service type is `LoadBalancer`
	// (optional, cloud specific)
	LoadBalancerClass string `json:"loadBalancerClass,omitempty" yaml:"loadBalancerClass,omitempty" mapstructure:"loadBalancerClass,omitempty"`

	// Redis&reg; Sentinel service Load Balancer IP
	LoadBalancerIP string `json:"loadBalancerIP,omitempty" yaml:"loadBalancerIP,omitempty" mapstructure:"loadBalancerIP,omitempty"`

	// Redis&reg; Sentinel service Load Balancer sources
	LoadBalancerSourceRanges []interface{} `json:"loadBalancerSourceRanges,omitempty" yaml:"loadBalancerSourceRanges,omitempty" mapstructure:"loadBalancerSourceRanges,omitempty"`

	// NodePorts corresponds to the JSON schema field "nodePorts".
	NodePorts *ValuesSentinelServiceNodePorts `json:"nodePorts,omitempty" yaml:"nodePorts,omitempty" mapstructure:"nodePorts,omitempty"`

	// Ports corresponds to the JSON schema field "ports".
	Ports *ValuesSentinelServicePorts `json:"ports,omitempty" yaml:"ports,omitempty" mapstructure:"ports,omitempty"`

	// Session Affinity for Kubernetes service, can be "None" or "ClientIP"
	SessionAffinity string `json:"sessionAffinity,omitempty" yaml:"sessionAffinity,omitempty" mapstructure:"sessionAffinity,omitempty"`

	// Additional settings for the sessionAffinity
	SessionAffinityConfig ValuesSentinelServiceSessionAffinityConfig `json:"sessionAffinityConfig,omitempty" yaml:"sessionAffinityConfig,omitempty" mapstructure:"sessionAffinityConfig,omitempty"`

	// Redis&reg; Sentinel service type
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// Additional custom annotations for Redis&reg; Sentinel service
type ValuesSentinelServiceAnnotations map[string]interface{}

type ValuesSentinelServiceHeadless struct {
	// Annotations for the headless service.
	Annotations ValuesSentinelServiceHeadlessAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`
}

// Annotations for the headless service.
type ValuesSentinelServiceHeadlessAnnotations map[string]interface{}

type ValuesSentinelServiceNodePorts struct {
	// Node port for Redis&reg;
	Redis string `json:"redis,omitempty" yaml:"redis,omitempty" mapstructure:"redis,omitempty"`

	// Node port for Sentinel
	Sentinel string `json:"sentinel,omitempty" yaml:"sentinel,omitempty" mapstructure:"sentinel,omitempty"`
}

type ValuesSentinelServicePorts struct {
	// Redis&reg; service port for Redis&reg;
	Redis float64 `json:"redis,omitempty" yaml:"redis,omitempty" mapstructure:"redis,omitempty"`

	// Redis&reg; service port for Redis&reg; Sentinel
	Sentinel float64 `json:"sentinel,omitempty" yaml:"sentinel,omitempty" mapstructure:"sentinel,omitempty"`
}

// Additional settings for the sessionAffinity
type ValuesSentinelServiceSessionAffinityConfig map[string]interface{}

type ValuesSentinelStartupProbe struct {
	// Enable startupProbe on Redis&reg; Sentinel nodes
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for startupProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for startupProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for startupProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for startupProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for startupProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

type ValuesServiceAccount struct {
	// Additional custom annotations for the ServiceAccount
	Annotations ValuesServiceAccountAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Whether to auto mount the service account token
	AutomountServiceAccountToken bool `json:"automountServiceAccountToken,omitempty" yaml:"automountServiceAccountToken,omitempty" mapstructure:"automountServiceAccountToken,omitempty"`

	// Specifies whether a ServiceAccount should be created
	Create bool `json:"create,omitempty" yaml:"create,omitempty" mapstructure:"create,omitempty"`

	// The name of the ServiceAccount to use.
	Name string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// Additional custom annotations for the ServiceAccount
type ValuesServiceAccountAnnotations map[string]interface{}

type ValuesServiceBindings struct {
	// Create secret for service binding (Experimental)
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`
}

type ValuesSysctl struct {
	// Override default init-sysctl container command (useful when using custom
	// images)
	Command []interface{} `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Enable init container to modify Kernel settings
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Image corresponds to the JSON schema field "image".
	Image *ValuesSysctlImage `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// Mount the host `/sys` folder to `/host-sys`
	MountHostSys bool `json:"mountHostSys,omitempty" yaml:"mountHostSys,omitempty" mapstructure:"mountHostSys,omitempty"`

	// Set container requests and limits for different resources like CPU or memory
	// (essential for production workloads)
	Resources ValuesSysctlResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Set container resources according to one common preset (allowed values: none,
	// nano, small, medium, large, xlarge, 2xlarge). This is ignored if
	// sysctl.resources is set (sysctl.resources is recommended for production).
	ResourcesPreset string `json:"resourcesPreset,omitempty" yaml:"resourcesPreset,omitempty" mapstructure:"resourcesPreset,omitempty"`
}

type ValuesSysctlImage struct {
	// OS Shell + Utility image digest in the way sha256:aa.... Please note this
	// parameter, if set, will override the tag
	Digest string `json:"digest,omitempty" yaml:"digest,omitempty" mapstructure:"digest,omitempty"`

	// OS Shell + Utility image pull policy
	PullPolicy string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty" mapstructure:"pullPolicy,omitempty"`

	// OS Shell + Utility image pull secrets
	PullSecrets []interface{} `json:"pullSecrets,omitempty" yaml:"pullSecrets,omitempty" mapstructure:"pullSecrets,omitempty"`

	// OS Shell + Utility image registry
	Registry string `json:"registry,omitempty" yaml:"registry,omitempty" mapstructure:"registry,omitempty"`

	// OS Shell + Utility image repository
	Repository string `json:"repository,omitempty" yaml:"repository,omitempty" mapstructure:"repository,omitempty"`
}

// Set container requests and limits for different resources like CPU or memory
// (essential for production workloads)
type ValuesSysctlResources map[string]interface{}

type ValuesTls struct {
	// Require clients to authenticate
	AuthClients bool `json:"authClients,omitempty" yaml:"authClients,omitempty" mapstructure:"authClients,omitempty"`

	// Enable autogenerated certificates
	AutoGenerated bool `json:"autoGenerated,omitempty" yaml:"autoGenerated,omitempty" mapstructure:"autoGenerated,omitempty"`

	// CA Certificate filename
	CertCAFilename string `json:"certCAFilename,omitempty" yaml:"certCAFilename,omitempty" mapstructure:"certCAFilename,omitempty"`

	// Certificate filename
	CertFilename string `json:"certFilename,omitempty" yaml:"certFilename,omitempty" mapstructure:"certFilename,omitempty"`

	// Certificate Key filename
	CertKeyFilename string `json:"certKeyFilename,omitempty" yaml:"certKeyFilename,omitempty" mapstructure:"certKeyFilename,omitempty"`

	// DEPRECATED. Use existingSecret instead.
	CertificatesSecret string `json:"certificatesSecret,omitempty" yaml:"certificatesSecret,omitempty" mapstructure:"certificatesSecret,omitempty"`

	// File containing DH params (in order to support DH based ciphers)
	DhParamsFilename string `json:"dhParamsFilename,omitempty" yaml:"dhParamsFilename,omitempty" mapstructure:"dhParamsFilename,omitempty"`

	// Enable TLS traffic
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// The name of the existing secret that contains the TLS certificates
	ExistingSecret string `json:"existingSecret,omitempty" yaml:"existingSecret,omitempty" mapstructure:"existingSecret,omitempty"`
}

type ValuesUseExternalDNS struct {
	// Extra annotations to be utilized when `external-dns` is enabled.
	AdditionalAnnotations ValuesUseExternalDNSAdditionalAnnotations `json:"additionalAnnotations,omitempty" yaml:"additionalAnnotations,omitempty" mapstructure:"additionalAnnotations,omitempty"`

	// The annotation key utilized when `external-dns` is enabled. Setting this to
	// `false` will disable annotations.
	AnnotationKey string `json:"annotationKey,omitempty" yaml:"annotationKey,omitempty" mapstructure:"annotationKey,omitempty"`

	// Enable various syntax that would enable external-dns to work.  Note this
	// requires a working installation of `external-dns` to be usable.
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// The DNS suffix utilized when `external-dns` is enabled.  Note that we prepend
	// the suffix with the full name of the release.
	Suffix string `json:"suffix,omitempty" yaml:"suffix,omitempty" mapstructure:"suffix,omitempty"`
}

// Extra annotations to be utilized when `external-dns` is enabled.
type ValuesUseExternalDNSAdditionalAnnotations map[string]interface{}

type ValuesVolumePermissions struct {
	// ContainerSecurityContext corresponds to the JSON schema field
	// "containerSecurityContext".
	ContainerSecurityContext *ValuesVolumePermissionsContainerSecurityContext `json:"containerSecurityContext,omitempty" yaml:"containerSecurityContext,omitempty" mapstructure:"containerSecurityContext,omitempty"`

	// Enable init container that changes the owner/group of the PV mount point to
	// `runAsUser:fsGroup`
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Image corresponds to the JSON schema field "image".
	Image *ValuesVolumePermissionsImage `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// Set container requests and limits for different resources like CPU or memory
	// (essential for production workloads)
	Resources ValuesVolumePermissionsResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Set container resources according to one common preset (allowed values: none,
	// nano, small, medium, large, xlarge, 2xlarge). This is ignored if
	// volumePermissions.resources is set (volumePermissions.resources is recommended
	// for production).
	ResourcesPreset string `json:"resourcesPreset,omitempty" yaml:"resourcesPreset,omitempty" mapstructure:"resourcesPreset,omitempty"`
}

type ValuesVolumePermissionsContainerSecurityContext struct {
	// Set init container's Security Context runAsUser
	RunAsUser float64 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`
}

type ValuesVolumePermissionsImage struct {
	// OS Shell + Utility image digest in the way sha256:aa.... Please note this
	// parameter, if set, will override the tag
	Digest string `json:"digest,omitempty" yaml:"digest,omitempty" mapstructure:"digest,omitempty"`

	// OS Shell + Utility image pull policy
	PullPolicy string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty" mapstructure:"pullPolicy,omitempty"`

	// OS Shell + Utility image pull secrets
	PullSecrets []interface{} `json:"pullSecrets,omitempty" yaml:"pullSecrets,omitempty" mapstructure:"pullSecrets,omitempty"`

	// OS Shell + Utility image registry
	Registry string `json:"registry,omitempty" yaml:"registry,omitempty" mapstructure:"registry,omitempty"`

	// OS Shell + Utility image repository
	Repository string `json:"repository,omitempty" yaml:"repository,omitempty" mapstructure:"repository,omitempty"`
}

// Set container requests and limits for different resources like CPU or memory
// (essential for production workloads)
type ValuesVolumePermissionsResources map[string]interface{}
